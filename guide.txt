=====Phần 4 chapter 3 video 25====

##1 - Chạy chương trình hello world##
	a) Để chạy được một chương trình website trong java spring cần có thêm thư viện web org.springboot.boot (spring-boot-starter-web) khi thêm vào thì vscode sẽ tự động kéo những thư viện này về
	Setup Spring for web = Update file pom.xml:
	Thêm phần này vào thẻ <dependencies/>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
	b) tạo một file java cùng cấp với file java mặc định trong main 
	import những thư viện liên quan đến web cần thiết
	org.springframework.web.bind.annotation.GetMapping
	org.springframework.web.bind.annotation.RestController

====Phần 5 chapter 4 Maven & cấu trúc dự án spring boot====

	video 30: cấu trúc folder và file
	src: chứa tất cả code ứng dụng 
	target: thư mục chứa mã code .class đã được dịch sang mã máy từ src để JVM nó hiểu 
		-> ứng dụng web khi chạy thì chạy trên thư mục target này 
	.vscode: thư mục giúp debug ứng dụng java trên vscode (có nhờ cài các extension như spring boot bashboard)
	.mvn: cách chúng ta chạy ứng dụng maven	
	.gitignore: chứa các loại file ko đẩy lên github 
		như chứa thư mục target vì cái này chứa mã dịch các file .class của chính máy mình hợp với máy mình chạy 
		nếu chạy trên MacOs hoặc thiết bị khác thì mã dịch trong các file .class sẽ khác 
		-> không nên đưa lên github
	file mvnw (để chạy trên MacOS) , file mvnw.cmd (để chạy trên window): là nơi chứa cách cấu hình, chạy dự án nhờ có 2 file này cấu hình mới dịch được từ các file code (src/) sang file mã máy (target/)
		đây là 2 file maven có thể build được dự án = câu lệnh: ./mvnw spring-boot:run 
		(thêm variable enviroment: JAVA_HOME value: C:\Program Files\Java\jdk-17)
	file pom.xml: chứa các cấu hình (dự án) thư viện, cách build dự án ~ packet.json (nếu code NodeJS) 	
	Readme.MD: nơi ghi thông tin về dự án 

	Ngoài ra: 
	JRE system library[JavaSE-17]: chứa all library mà java cài đặt sẵn khi cài đặt java version 17
	Maven dependencies: chứa những thư viện mà file pom.xml cài đặt vào (tức là khi cấu hình 1 library vào file pom.xml thì library này sẽ được tự động down về folder này)

	** những thư mục chứa dấu chấm phía tước chỉ là môi trường giúp chạy code (hạn chế chỉnh sửa)

	video 30: maven ~ gradle-groovy ~ gradle-kotlin
	maven là 1 dự án của apache mục đích sử dụng maven: 
		+ làm cho quá trình build nhanh hơn 
		(ví dụ: để tạo ra target ta chỉ cần viết file code và cấu hình còn lại maven sẽ giúp quá trình tạo)
		+ thống nhất 1 tiêu chuẩn khi build 
		(ví dụ: dùng pom.xml để thêm các dependecies 

	
	video 33: File POM (Project Object Model) ~ packet.json(NodeJs)
	với dự án spring khi khởi tạo sẽ có sẵn file POM
	tiền tố .xml là cú pháp gõ code ~ html
	dùng để quản lý dự án: (compile&build&run)
		+ <groupId/>: tên miền web ghi ngược 
		+ <artifactId/>: tên ứng dụng
		+ <version/>: version phát triển phần mềm
		...
		Những cái này được quản lý thông qua Maven để đảm bảo mỗi thư viện cài đặt vào nó phải có tên của nó 
		ví dụ: cùng 1 <groupId>org.springframework.boot</> nhưng có 2 <artifactId/> chính là 2 service

====Phần 6 - chapter 5 spring and inversion of control====
	Làm được 3 phần: 
		**Trong 1 ứng dụng thì có nhiều component được quản lý bởi Core Container 
		web: học về web
		data access: học về ORM 
		Core container: spring boot đã hỗ trợ
		- Beans: là một thực thể được tạo ra từ class của chúng t hoặc những class mặc định và những Beans này được quản lý bởi Core Container (mỗi class chúng t tạo ra đó là 1 Beans có kí hiệu giống hạt cafe bên trái code) -> tối ưu hóa
		
		Component: là cách chúng ta hiểu cách quản lý code như là 1 dự án thì bao gồm nhiều component trong mỗi component nó sẽ chứa các Beans mà Beans là đại diện cho các class của chúng ta viết 
		@Bean
		@Component: là cách hiểu làm sao chúng ta code và giao tiếp với Java Spring
		**Cách thức để spring có thể quét từ các file class thành các Beans để Container quản lý 
			Thường nó sẽ quét từ file class tạo mặc định khi khởi tạo dự án như LaptopsShopApplication.java trong này nó sẽ có @componentScan (đây là định dạng quét) và nó chỉ quét được những class cùng cấp hoặc những class trong folder cùng cấp với nó các class khác sẽ có @componet cái này giúp class đó đăng ký được quản lý bởi Container 
		@componentScan: giúp nhận dạng Beans và quản lý dự án 
		Quản lý dự án (inversion of control IOC and dependency injection) đây là 1 design pattern
			IOC là cách viết code sao cho hiệu quả và dependency injection là công cụ để thực hiện hóa nó 
			một dự án cần nhiều component -> nhiều class được quản lý bởi Container và những class này có mối quan hệ với nhau ví dụ class A phụ thuộc vào B, C phụ thuộc vào B thì lúc này chúng t chỉ cần làm việc với A và C khi nào dùng B thì IoC này sẽ inject B vào -> tăng tính hiệu quả của design pattern này
			chứ nếu A ban đầu luôn có B và C cũng như vậy khi B thay đổi thì A và C cũng thay đổi theo -> ko hiệu quả 
			Và quan hệ của những class này là Dependency ( tức là class này có sử dụng thuộc tính là class kia chứ ko phải là quan hệ cha con)
			Viết code theo 2 keywords tightly coupled (ràng buộc chặt chẽ vào nhau) và loosely coupled(nơi lõng nhau ra) nên làm loosely coupled để các class hạn chế phụ thuộc vào nhau 
Ví dụ về tightly coupled ở đây trong constructor của Car khởi tạo mặc định 1 engine -> car phụ thuộc chặt chẽ vào engine nếu muốn thay đổi engine ở car phải thay đổi cả class engine
// Class Engine
class Engine {
    public void start() {
        System.out.println("Engine started.");
    }
}

// Class Car
class Car {
    private Engine engine;

    public Car() {
        engine = new Engine(); // Car trực tiếp khởi tạo Engine
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving.");
    }
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.drive();
    }
}


Ví dụ về loosely coupled: ở đây car ko phụ thuộc trực tiếp vào engine nữa và có thể linh hoạt thay đổi engine theo cách ta muốn dependency injection cũng được thể hiện ở đây chúng t chỉ khởi tạo ra engine mà ko gán giá trị cho nó khi nào cần chúng ta mới inject nó vào (gán giá trị) 
// Interface Engine
interface Engine {
    void start();
}

// Class PetrolEngine
class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol engine started.");
    }
}

// Class DieselEngine
class DieselEngine implements Engine {
    public void start() {
        System.out.println("Diesel engine started.");
    }
}

// Class Car
class Car {
    private Engine engine;

    // Dependency Injection qua constructor
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving.");
    }
}

// Main Class
public class Main {
    public static void main(String[] args) {
        Engine petrolEngine = new PetrolEngine();
        Car petrolCar = new Car(petrolEngine);
        petrolCar.drive();

        Engine dieselEngine = new DieselEngine();
        Car dieselCar = new Car(dieselEngine);
        dieselCar.drive();
    }
}
***xem thêm ví dụ về tạo thêm phương thức riêng cho từng class cha để lấy ra giá trị cần để tránh sử dụng trực tiếp giá trị của các element trong class cha -> sự phụ thuộc chặt chẽ 
		Chung quy ở đây muốn injection thì cần phải có injector là chính framework này đã cung cấp hỗ trợ chúng t chỉ có việc code theo format của nó 	

====Phần 7 chapter 6 Spring Security====

##1 - spring boot devtool: hỗ trợ việc chạy restart lại ứng dụng khi sửa code nhanh hơn##

	bình thường chúng ta cần làm 2 bước sửa code lưu code và restart lại ứng dụng 
	tool này sẽ giúp bỏ qua bước restart
	cần cài thêm thư viện này: 
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
	để kiểm tra thư viện đã được kéo về chưa thì chúng ta vào maven -> source -> chọn dependencies 

##2 - @GetMapping: dùng để thiết lập route tạo được link url trong website của chúng ta##

	Dùng để phần quyền người dùng trong security

##3 - database nên dùng SQL vì Java là 1 ngôn ngữ hướng đối tượng ràng buộc chặt chẽ thì SQL là sự lựa chọn hoàn hảo hơn NoSQL##

	javascript - noSQL
	NodeJS - noSQL
	
##4 - setup MySQL Nên dùng docker hơn là cài đặt 1 MySQL về máy cần cài:##

	MySQL Server: nơi lưu trữ
	MySQL WorkBench: nơi view xem thông tin trong database
	MySQL Shell: nơi gõ lệnh
	...

##5 - setup MySQL cho spring boot##

	Thêm 2 dependencies
	<dependeny>
		<groupId>org.springframework.boot</>
		<actifactId>spring-boot-starter-data-jpa</>
	</>
	<dependeny>
		<groupId>mysql</>
		<actifactId>mysql-connector-java</>
	</>

	Trong file pom.xml có <parent></> là org.springframework.boot đây là 1 package lớn những dependency con dependency có <groupId></> là org.springframework.boot sẽ được định nghĩa Version thông qua <parent></> này -> ko cần định nghĩa <version></>
	nhưng ở đây <groupId>Mysql</> ko có parent để cấu hình version này nên phải thêm trực tiếp nó vào
	search maven mysql-connector-java để lấy version mới nhất thêm <version>8.0.33</> vào trong <dependency></> có <groupId>mysql</>
	
	Connect database: 
	Truyền thống thì kết nối thông qua Java Database Connectivity (JDBC)
	hiện tại thì kết nối thông qua file resources/application.properties tất cả các thuộc tính cần làm thì cấu hình ở đây thêm vào 
		spring.jpa.hibernate.ddl-auto=update	
		spring.datasource.url=jdbc://${MYSQL_HOST:localhosts}:3306/laptopshop
			(MYSQL_HOST ở đây là một tham số môi trường lấy tham số mặc định là localhost)
		spring.datasource.username=root
		spring.datasource.password=Thanhtrong@0510
		spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
			(nếu dùng postgresSql thì thể mysql -> postgressql)
		spring.jpa.show-sql: true 
			(cho phép show câu lệnh sql)

##6 - Security##

a) authentication (bạn là ai 'first') & authorization(bạn có thể làm gì 'second'): đọc tài liệu
	ví dụ: 
		authentication: là đăng nhập vào face = tài khoản mật khẩu -> đn vào được xác nhận đc bạn là ai
		authorization: khi đn thành công tức là đã xác thực bạn là ai rồi -> bạn có thể like ảnh người khác, chỉnh sửa comment của chính mình, ko thể xóa bài của người khác .... 
b) nguyên tắc khi làm security: 
	- Trust nothing
	validate every request: luôn xác thực all requests
	luôn xác thực data gửi vào hệ thống 
	- Xác định quyền hạn cho hệ thống: xác định được các actor là ai và quyền hạn của họ 
	- nhiều lớp security: firewall, middleware, ...
	- kiến trúc của security nên đơn giản -> dễ maintain

##7 - setup string security##

	Thêm dependency
	<dependency>
		<groupId>org.springframework.boot</>
		<actifactId>spring-boot-starter.security</>
	</>
	khi thêm vào có thể chương trình chưa đồng bộ với security này thì khi bấm lưu hãy bấm yes ở dưới 
	mặc định khi cài xong: khi vào localhost:8080 || localhost:8080/user || localhost:8080/admin đều redirect chúng ta về localhost:8080/login 
	tự động có 2 trang localhost:8080/login và localhost:8080/logout - username=user, password sẽ hiển thị dưới phần terminal khi chạy lưu ý là password này chỉ có tác dụng trong 1 phiên làm việc (session) khi chạy lại chương trình sẽ có password khác 
	-> mặc định khi cài đặt thành công nó đã tạo ra chức năng bảo vệ ứng dụng của chúng ta
	-> khi chạy thì terminal sẽ hiện lệnh xem logs: 
	mặc định app được bảo vệ bởi DefaultSecurityFilterChain bao gồm nhiều lớp chain/filter xem những filter này ở Tài Liệu
	spring security: 
	một số khái niệm:
		filter chain
		authentication managers
		authentication providers
	Ưu điểm: dễ sửa đổi, mặc định mọi resources của hệ thống đều được bảo về 

##8 - Sơ lược về mô hình spring mvc##

	Bình thường ứng dụng của chúng là là mô hình: 
	Request(thao tác của người dùng) -> server(java, xử lý ) -> response
	thường request sẽ chạy vào controller(HelloWorldController.java) ở đây sẽ xử lý và gửi response lại cho người dùng -> nếu theo mô hình này sẽ không bảo về được ứng dụng 
	-> spring security ra đời thì request nó phải đi qua spring security này trước rồi mới đến controller đấy chính là lý do chưa vào đường link nào của ứng dụng cũng phải login 

	Cách thức hoạt động của spring security: 
	spring security chính là middleware của hệ thống như NodeJs 
	trong mô hình sẽ có các Filter Chain gồm chiều security filter thực hiện từng filter một cách tuyến tính (cái trên chạy xong cái dưới mới chạy) "các lớp phòng thủ" 
	spring security đã viết cho chúng ta sẵn những lớp phòng thủ này -> muốn customize thì chỉnh sửa code vào những lớp đã có sẵn đấy 
	thường 1 request muốn gửi đến server cần thông qua DefaultSecurityFilterChain mặc định của spring security gồm nhiều lớp chain/filter sẽ lọc những request này -> request hợp lệ/ko hợp lệ
	một số filter/chain trong DefaultSecurityFilterChain cần dùng: 
	org.springframework.web.filter.CorsFilter@4c1d59cd: dùng để kết nối frontend và backend
	org.springframework.security.web.csrf.CsrfFilter@318c68d	org.springframework.security.web.authentication.logout.LogoutFilter@4733f6f5
	security.web.authentication.UsernamePasswordAuthenticationFilter@56cc9f29	security.web.authentication.ui.DefaultLoginPageGeneratingFilter@41ccb3b9
	security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@76cf841
	security.web.savedrequest.RequestCacheAwareFilter@f1266c6
	org.springframework.security.web.access.intercept.AuthorizationFilter@415ef4d8: cái này luôn cuối cùng vì đây là bước phân quyền người dùng sau khi đã đăng nhập thành công đã xác thực người dùng đó là ai rồi

====Phần 8 chapter 7 Spring MVC====

	**sửa lỗi tồn đọng
	Format code cho xml trong vscode cài thêm extension xml tools 		
	sửa dependency của mysql <groupId>com.mysql</> <artifactId>spring-boot-starter-j</> (org.springframework.boot version từ 3. trở đi dùng cái này ko cần điền version mà giao cho springboot parent cấp còn dưới 3. dùng <groupId>mysql</> <actifactId>spring-boot-starter-java</>

##1 - Mô hình MVC##

	Viết code theo mô hình MVC: Model - View - Controller:
	View: chịu trách nhiệm render(hiển thị) giao diện website
	Model: các đối tượng sử dụng hệ thống được mô hình hóa qua OOP. Với Spring models bao gồm các tables trong database 
	Controller: chịu trách nhiệm xử lý dữ liệu - giúp tương tác giữa View và Controller (là nơi xử lý logic code)
	Spring FrameWork đã có hỗ trợ mô hình MVC -> ko cần cấu hình thêm
 
##2 - Java Annotation ~ Decorator trong NodeJs##

a) mục đích giúp Decorate 1 class giúp tăng sử hiệu quả của class 
	Mỗi Annotation chỉ có tác dụng đối với A(class, function, element) ngay sau nó
	ví dụ: 
	Annotation @override trước 1 function -> java có thể hiểu đây là 1 function từ child override của parent
	Java Spring các Annotation có thể dùng cho class, function, element kí hiệu '@'
	
	Annotation @SpringBootApplication giúp class chạy đầu tiên khi run ứng dụng có
		@SpringBootConfiguration: config Spring Boot
		@EnableAutoConfiguration: enable phần tự động cấu hình Java
		@ComponentScan: định nghĩa cách thức Scan 
		...
	Khi 1 class chạy thì nó sẽ đọc Annotation -> nó sẽ truyền thêm 1 meta-data để nhận biết loại class theo annotation đó

b) cấu hình lại username, password cho trang login
	cấu hình vào file .properties
	spring.security.user.name=Thanhtrong
	spring.security.user.password=Thanhtrong@0510
	
	**disable tạm thời spring security = cách chỉnh sửa lại Annotation @SpringBootApplication bỏ đi phần security đó
	@SpringBootApplication(exclude = org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class)
	mình dùng exclude để loại bỏ đi 1 phần cái tự động config khi cài đặt Security Spring 
	include <> exclude
	
c) Cấu hình cấu trúc dự án theo chuẩn 
	https://github.com/hoidanit-be-java-spring-mvc/02-java-react-with-jhipster
	cấu hình theo link này 
	thêm các folder: config, service, controller (web nếu dự án lớn trong này sẽ chứa các controller), domain(models/entity), repository, security
	
	xóa HelloWorldController.class

d) Bắt đầu code
	Trái tim của mô hình MVC là controller
-Controller: chỉ để điều hướng 
	(1)Tạo class UserController để biến class này thành controller thì dùng annotation @controller trong class này cần định nghĩa mô hình MVC thêm những Function ứng với từng View 
	public String getHomePage() -> làm sao để truy cập được Phương thức này -> dùng annotaion @RequestMapping giống @Route ở Flask ở đây là gửi 1 yêu cầu lên server(java) gửi từ trình duyệt web 
		Nếu chỉ viết tới đây chạy chương trình truy cập localhost:8080 sẽ lỗi 404 vì đây chưa đủ mô hình MVC chưa tìm thấy các file tĩnh như html, css, js, images  
		-> thêm vào folder Service
	(2) Viết code dùng Pattern dependency Injection trong class UserController tạo 1 element	
		private UserService; 
		dùng hàm tạo để khởi tạo giá trị cho UserService	
		và ở hàm getHomePage() return userService.HandleGetHomePage() 
		Từ đây đã ra được mô hình MC: từ models -> controller nhưng chưa có View -> vẫn chưa hiển thị được 
			** tất nhiên models ở đây sau này sẽ là domain nhưng hiện tại chỉ test 
	(3) chuyển @Controller -> @RestController để có thể hiển thị ra màn hình dùng mô hình Restful API, chuyển @RequestMapping -> @GetMapping
		

-Service: 
	(1)Tạo class UserService thêm Annotation cho class này @Service tạo 1 function HandleGetHomePage()
		
Render view HTML 
File Tĩnh là các file ít thay đổi thường sẽ public như file html, css, javascript, images

##4 - Quay lại mô hình MVC bỏ đi Rest API##

	- sử dụng lại @Controller 
	- Tạo View (view là file static html để hiển thị ra màn hình)
		tạo thư mục src/main/resources/static/hello.html
	- quay lại UserController.GetHomePage cho nó return về tên của file html hello.html
	-> Controller điều hướng tới file tĩnh -> đã có view hiển thị được ra màn hình
	** đối với spring tất cả các file đặt trong static nó sẽ hiểu là những file được public ra ngoài internet thông thường là View 
	-> vẫn còn thiếu models những nếu dùng các file tĩnh như ngày thì rất khó để generate ra được data động tức là khó lấy dữ liệu từ models rồi dùng controller điều hướng đến view được 
	-> cần sử dụng View Engine 
	**@RequestMapping(đường link url / chính là localhost:8080)
	**cần trả về String vì java ko hiểu đâu là file của chúng ta -> ta phải đưa tên file cho nó -> cần return về String

##5 - dùng view engine cách truyền data từ models - controller - điều hướng dữ liệu đó đến view để hiển thị##

	view engine là công cụ giúp code html ít đi - giải quyết được bài toán tạo ra nội dung động cho chúng ta = cách viết code java trực tiếp vào file html = Spring View Technologies trong nhóm này chúng ta dùng JSP (Java Server Pages) là một View Engine ~ EJS(NodeJs), Blade(Lavarle) sau này nên tìm hiểu về Thymeleaf

##6 - Setup JSP##

	thêm các thư viện
	<dependency>
	    <groupId>org.apache.tomcat.embed</groupId>
	    <artifactId>tomcat-embed-jasper</artifactId>
	</dependency>

	<dependency>
	    <groupId>jakarta.servlet.jsp.jstl</groupId>
	    <artifactId>jakarta.servlet.jsp.jstl-api</artifactId>
	</dependency>

	<dependency>
	    <groupId>org.glassfish.web</groupId>
	    <artifactId>jakarta.servlet.jsp.jstl</artifactId>
	</dependency>

	**Thường những cache được lưu vào thư mục ../.m2/
##7 - Cấu hình JSP có 2 cách: khi cấu hình ở đây nó sẽ chỉ tự động load những file view được cấu hình sẽ ko load file tĩnh mặc định nữa##

cách 1: cấu hình trực tiếp vào .properties
	spring.mvc.view.prefix=/WEB-INF/view/ 
	spring.mvc.view.suffix=.jsp
	**mvc.view là chúng ta dùng theo mô hình mvc
	**prefix là nơi cấu hình thư mục mà chúng ta muốn quét để tìm các file hiển thị ra view 
	**suffix là nơi cấu hình extension của các file cần tìm trong prefix -> khi return ở controller chỉ cần return tên file ko cần return extension
	Tạo thêm 1 folder webapp ở trong main cùng cấp với folder resources để chứa /WEB-INF/view/:
		- Trong resources/static: sẽ chứa các file tỉnh 
		- các file render động sẽ lưu trong webapp/WEB-INF/view/ là những file động ko cho public 

cách 2: cấu hình thông qua code đặt trong config/WebMvcConfig.java theo format 
@Configuration
@EnableWebMvc
public class WebMvcConfig implements WebMvcConfigurer {

  @Bean
  public ViewResolver viewResolver() {
    final InternalResourceViewResolver bean = new InternalResourceViewResolver();
    bean.setViewClass(JstlView.class);
    bean.setPrefix("/WEB-INF/view/");
    bean.setSuffix(".jsp");
    return bean;
  }

  @Override
  public void configureViewResolvers(ViewResolverRegistry registry) {
    registry.viewResolver(viewResolver());
  }
}

**Nhờ có @EnableWebMvc -> Spring nhận biết được chúng ta muốn cấu hình MVC
	 @Configuration: config này dùng để viết @Bean này giúp class này tối ưu để container quản lý 
**Đặt trong thư mục config theo mô hình của project trong github
**Nên dùng code vì đối với Spring Security sẽ ko có .properties cho chúng ta cấu hình 	

##8 - Truyền từ Controller vào view = JSP có 3 cách khi dùng framework##

	Model(đơn giản nhất)
	ModelMap(tương tác với connection, array, ...)
	ModelAndView(return cả view cả data trong 1 lời gọi)
Dùng model:
	trong controller/UserController/getHomePage truyền vào tham số (Model model)
	**Model ở đây là Spring framework đã có sẵn và mình dùng mô hình MVC nên nó mới hiểu được
	Nội dung hàm mình sẽ thêm thuộc tính cho model
	model.addAttribute() 
	**đây là thêm 1 object trong javascript gồm key là tên dùng để truy cập và value 
	@RequestMapping("")
    	public String getHomaPage(Model model) {
        String test = this.userService.handleGetHomePage();// lấy dữ liệu từ database
        model.addAttribute("test", test);
        String SinhVien = "Thanh Trong";
        model.addAttribute("TenSinhVien", SinhVien);
	**sau khi controller xử lý xong dữ liệu
        return "hellofromjsp";//trả về cho view 
    }

**ở đây xem như this.userService.handleGetHomePage() là database chúng ta lấy dữ liệu về controller qua biết test
khi chúng ta sử dụng MVC spring sẽ nhận biết được Model chúng t sẽ dùng nó sẽ controller xử lý dữ liệu để gửi cho view = cách model.addAttribute(name, value). name, value ở đây là 1 object theo javascript
khi return hellofromjsp thì trong file JSP này đã có những dữ liệu từ controller gửi lên là được truy cập thông qua ${name} được truyền lên 
a) cú pháp của JSP
	khi in ra 1 biến được gửi lên từ controller ở trong file jsp ${name}
b) JSPL (JSP Standard Tag Library) là phần mở rộng của JSP 
	khi in ra 1 biến được gửi lên từ controller ở trong file jsp <c:out value="${name}"/> c: ở đây tượng trưng cho thư viện core 
	nên dùng cái này khi dùng loop, ... giúp tăng hiệu năng 
	<%@page contentType="text/html" pageEncoding="UTF-8"%> 
	<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
	**<%@page/> set file của chúng ta là dạng text/html
	<%@ taglib> là để chúng ta cấu hình chúng ta dùng thư viện nào ở đây là http://java.sun.com/jsp/jstl/ và prefix="c" là tiền tố 'c' thể hiện chúng ta dùng /core 


##9 Tích hợp bootstrap và JQuery import vào chính file .jsp##

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

***khi cấu hình JSP thì chúng ta chỉ cho nó load các file JSP trong webapp -> nó sẽ ko load các file tĩnh trong /resources/static như mặc định nữa -> xóa thư mục static 
thêm vào thư mục /webapp/resources đây sẽ là nơi chứa website app của chúng ta như css/, js/, images/, ...

***cấu hình thêm để tối ưu các đường dẫn khi dùng thẻ link trong file JSP để link tới css, js ....
@Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/css/**").addResourceLocations("/resources/css/");
    }
đầu tiền /resources/css sẽ luôn được link tới nếu t điền bất kì url nào = /css/....
/css/**: 2 dấu ** ở đây thể hiện nó sẽ truy cập tất cả folder/file trong thư mục /css/

##10 Tạo trang http://localhost:8080/admin/user là trang tạo user Create.jsp##

	Trong /webapp/WEB-INF/view tạo /admin/user trong này tạo 1 file Create.jsp tạo ra giao diện = bootstrap
	<div class="container mt-5"> 				
		<div class="row"> 
			<div class="col-md-6 col-12 mx-auto" >
				<hr>
				<form></form>
			</div>
		</div>
	</div>
	
	** class=container mt-5 thì container sẽ giúp tạo khoảng cách 2 bên (margin left, right để form ko sát với ngoài biên) mt-5 là margin top 5 đơn vị = 3em theo quy định của bootstrap (1-5 đơn vị)
	   class=row sẽ đi kèm với container bù trừ với nó 
	   Trong bootstrap (dùng grid) chia màn hình máy tính thành 12 phần (12 columns)
	   -> class="col-md-6 col-12 mx-auto" đối col-6 tức là lấy 1/2 màn hình thêm -md là để hiển thị trên laptop, col-12 hiển thị trên điện thoại sẽ là full màn hình, mx-auto thì x ở đây chính là left và right mx là margin left, right auto thì nó sẽ tự động căn giữa màn hình 
	
	Trong controller tạo 1 class có @RequestMapping("/admin/user") và return về "/admin/user/Create.jsp" ở đây chúng ta đã cấu hình mặc định sẽ tìm trong folder /WEB-INF/view nên chỉ cần điền url đối với view

##11 gửi data với HTML Form##

	@RequestMapping() mặc định khi sử dụng ko điền method cho nó thì sẽ là GET lấy data nếu muốn truyền data từ client lên server thì ta dùng method POST
	@RequestMapping(value="url", RequestMethod.POST) thêm 1 class như này làm controller nhận request khi submit từ form

	thêm <%@taglib uri="http://www.springframework.org/tags/form" prefix="form"%> vào file JSP đây là thư việc của JSPL để làm việc với form 
	khi thêm thư viện thì thêm form: vào trong các thẻ trong <form:form></form> có hỗ trợ thêm thuộc tính path để thay thế cho id 
	để có thể cho controller biết thuộc tính đã có path là của form nào thì chúng ta dùng annotation modelAttribute="name" name này sẽ đại diện là 1 object gửi đi những cái path đặt trước đó là element của name này 
	modelAttribute dùng ở 2 nơi 1 là @modelAttribute annotation ở controller để xử lý dữ liệu 
				    2 là truyền trực tiếp vào form để chỉ định những modelAttribute phải có tên khác nhau và chỉ dùng được khi sử dụng <form:form> của thư viện <%@taglib uri="http://www.springframework.org/tags/form" prefix="form" %> đã được import vào
	khi chúng ta dùng trực tiếp trong form thì cần phải có 1 biến là chính cái name ở controller ở class có method GET link cái JSP chứa cái form đó nếu ko khi chạy sẽ hiện lỗi 500 Việc thêm thuộc tính  
		model.addAttribute("newUser", new User()); //đặt trong function của class GET biến này sẽ gửi lên view file JSP làm value của modelAttribute value này sẽ là 1 object ở view sẽ lấy dữ liệu nhập vào từ form rồi gửi về controller nhận ở function FOST để xử lý 
		**Lưu ý những thuộc tính trong newUser phải có trong class User và ko được sai tên nếu ko sẽ bị lỗi mặc dù là hàm khởi tạo không tham số (path của newUser phải trùng với những element trong class User)	
		
	
	Để nhận và xử lý dữ liệu thì thêm @modelAttribute trong tham số của hàm ở class POST trong controller 
	@RequestMapping(value = "/admin/user/createuser", method = RequestMethod.POST)
    	public String CreateUser(Model model, @ModelAttribute("name") User trongNguyen) {
        System.out.println("run here" + trongNguyen.toString());
        return "hellofromjsp";
    }
	với @ModelAttribute("name") là lấy modelAttribute nào trong JSP
	    User là kiểu dữ liệu 
	    trongNguyen tên biến 
	từ đây chúng ta đã nhận được dữ liệu từ view gửi về controller 

**Lưu ý: 
ở GetMapping khi dùng Model đưa 1 object lên view = model.addAttribute() -> nó chỉ thực hiển việc đưa Object này lên và có thể dùng Object này thông qua ${} 

nếu có thiết lập ModelAttribute ở form thì phải đặt tên giống với tên được Model đưa lên còn lại toàn bộ dữ liệu trong Object này khi truyền về Post sẽ được quyết định bởi Form: những thuộc tính của Object này lấy giá trị bởi các thuộc tính path trong các tag input ở những tag này vẫn có thể sử dụng dữ liệu Object được đưa lên qua ${} -> phải gán hoặc chỉnh sửa dữ liệu cho các path này nếu các path này ko có dữ liệu -> thì nó sẽ gửi về POST giá trị null/0 đối với path đó của Object được định nghĩa bởi ModelAttribute ko liên quan tới Object được Get gửi lên 

====Phần 9 chapter 8: Spring Data với JPA và hibernate====

1 - Spring cung cấp Spring data là công cụ giúp chúng ta tương tác với database một cách đơn giản 
	- Trong này nó sẽ cung cấp 1 đối tượng Repository nhờ đối tượng này chúng ta ko cần viết câu lệnh SQL nhưng vẫn truy vấn vào database được 
	- chúng ta sẽ sử dụng 1 model JPA trong Spring Data 

##2 - Cài đặt thư viện JPA##
	<dependency>
		<groupId>org.springframework.boot</>
		<actifactId>spring-boot-starter-data-jpa</>
	</>
	**khi cài công cụ có chữ start mô hình chung nó đã cài đủ những công cụ cần thiết //ở đây nó đã cài sẵn hibernate

##3 - tương tác với SQL có 2 cách:##

	- Sử dụng JDBC: Java Database Connectivity 
	đây là cách chúng ta kiểm soát database thông qua các câu lệnh truy vấn như select, update, insert, ...
	hoạt động: Tạo 1 kết nối tới database -> thông qa đó dùng câu lệnh truy vấn 
	- Sử dụng ORM(SQL) / ODM (NoSQL):
	ORM = Object Relational Mapping
	ODM = Object data/document Mapping
	đây là cách chúng ta sử dụng database thông qua 1 object/đối tượng -> ko cần viết câu lệnh SQL 
	Ưu điểm: là cú pháp dùng chung cho nhiều loại SQL chứ nếu dùng JDBC thì mỗi loại lại có mỗi loại truy vấn khác nhau
	Nhược điểm: Hiệu năng giảm hơn so với viết câu lệnh truy vấn thông qua dùng JDBC

##4 - Sử dụng Hibernate để dùng ORM thao tác với database##

Mô hình: 
	Spring <->Spring data JPA <-> JPA <-> Hibernate <-> database 
	chúng ta đang dùng spring để làm ứng dụng và muốn connect tới database thì cần Spring data và ở đây chúng ta dùng Spring data JPA cái này nó lại dựa trên JPA (Java Persistence API: là 1 API mà Java cung cấp) -> ở đây chúng ta đã có thể connect tới database nhưng đôi khi sử dụng API của Java để tương tác với database khá dài dòng, ... -> công cụ/framework Hibernate (chứa JDBC) ra đời được kế thừa và phát triển thêm từ JPA 
	hibernate giúp chúng ta viết ORM và nó sử dụng JPA để thao tác với data

##5 - Debug java với VScode là debug phía backend##

	không cần cài thêm công cụ gì khác 
	đối với vscode có 1 thư mục .vscode là nơi lưu cấu hình của việc debug để chạy được chế độ debug chúng ta có file launch.json đây là vscode tự động sinh khi sử dụng extension bashboard nếu ko có file này sẽ ko chạy được chế độ debug 
	hoạt động: bấm vào bashboard chọn dự án chọn debug - terminal sẽ xuất hiện chữ debug thay vì chữ run 
		   dùng breakpoint để dừng tại dòng để kiểm tra giá trị 
	
##6 - Entity (trong ứng dụng đặt là domain)##

	entity là thực thể ~ actor là những tác nhân tham gia vào hệ thống 
	bản chất entity là 1 class của Java đại diện cho 1 table trong database
	-> entity là models trong mô hình MVC
	Để tạo 1 đối tượng xoay quanh Object và ko cần dùng câu lệnh truy vấn -> chúng ta sẽ viết hoạt động của 1 đối tượng để tạo 1 database chứ ko viết câu lệnh truy vấn thông thường mà chúng ta sẽ mô hình hóa nó lên 	
	
	Để 1 cái trở thành 1 entity -> dùng annotation @Entity phải import nó phải liên quan đến JPA (Java/javax/jakarta persistence API)  entity là 1 trong những API của JPA 	
	khi dùng @Entity vào 1 class -> trong class này phải sử dụng thêm Annotation @Id để xác nhận 1 entity(table) đã có 1 ID (primary key) (@GeneratedValue(strategy = GenerationType.IDENTITY số tự tăng)
	-> sau khi cấu hình xong chạy chương trình chỉ = thêm 2 annotation && đã kết nối với database cấu hình ở .properties thì nó đã tự động tạo table theo định dạng của entity đó 
	**tên biến trong java fullName -> table: full_name vì trong database ko phân biệt chữ hoa chữ thường 

##7 - Mô hình MVC kết hợp với Spring Data##

** đặt tên models là domain chứ ko phải entity/model vì dựa theo base của jhipster ở đây nó đặt là domain là dựa trên 1 design pattern gọi là domain-driven design (domain ở đây sẽ quyết định hướng thiết kế của dự án vì trước khi viết view hoặc controller trc hết t phải tạo ra 1 domain cho cái đó như xác định dự án có bao nhiêu thực thể/actor và nó có thuộc tính gì -> mọi thứ phải xuất phát từ domain)

**Repository Pattern (là công cụ kết nối tới database)
Mô hình này gồm 3 lớp để kết nối đến database 
	Lớp 1: Domain Model Layer (lớp model/domain) @Entity
	Lớp 2: Infrastructure-Persistence Layer(Repository) @Repository 
	Lớp 3: Data tier(lớp data cho phép kết nối tới các bảng trong database)

	**tới đây ta đang hoàn thành Lớp 1 và Lớp 3 (đã có model trong domain và có các Annotation kết nối với db) đã có thể kết nối và sử dụng được database nhưng khả năng mở rộng và bảo trì kém -> tạo ra mô hình Repository Pattern -> chia nhỏ bớt các chức năng ra (giống microservices) để dễ nâng cấp bảo trì 
 -> muốn theo mô hình này phải viết thêm 1 lớp repository lớp này chỉ làm 1 việc kết nối xuống database còn models sẽ chỉ dùng để định danh repository sẽ dùng những định danh này 

Thực hiện tạo 1 user cho database thông qua form dùng Repository Pattern (domain, repository,sql) && Sử dụng Service && Viết code theo dependency injection 
- tạo repository/UserRepository.java để biến nó thành repository -> dùng annotation @Repository ở đây chúng ta sẽ ko định nghĩa ra 1 class mà là 1 Interface (java spring muốn giấu đi quá trình xử lý chỉ show ra muốn làm gì và làm ntn thì java spring nó đã làm sẵn) với nội dung 	
	
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
    User save(User user);
}

- cấu hình lại controller viết code theo dependency injection
// final theo chuẩn dependency injection (ko thay đổi giá trị sau khi khởi tạo)
    private final UserService userService;
    private final UserRepository userRepository;

    public UserController(UserService userService, UserRepository userRepository) {
        this.userService = userService;
        this.userRepository = userRepository;
    }

//chỉnh lại chỗ method POST khi nhận dữ liệu từ view submit 
@RequestMapping(value = "/admin/user/createuser", method = RequestMethod.POST)
    public String CreateUser(Model model, @ModelAttribute("newUser") User newUser) {
        this.userRepository.save(newUser);
} 
ở đây chưa hiểu=)) là interface UserRepository sao tạo được đối tượng ??? và abstract function save() ko có nội dung nhưng vẫn hoạt động=)) lưu 1 user truyền vào xuống database hàm save tự biết được nếu id=0/null thì nó sẽ hiểu là tạo đối tượng mới và dùng identity để tăng giá trị cho Id 

=== đoạn code sửa trong method POST là chưa phải mô hình hoàn chỉnh vì chúng ta đang sử dụng trực tiếp method của repository để chạy -> phải dùng service tạo 1 mô hình hoàn chỉnh tạo 1 class trong service tạo method xử lý add người dùng và dùng repository trong này -> trong controller t chỉ cần gọi method tường minh từ service ===

Sửa trong Service 
@Service
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public User handleSaveUser(User user) {
        return this.userRepository.save(user);
    }

Sửa lại method POST trong controller
@RequestMapping(value = "/admin/user/createuser", method = RequestMethod.POST)
    public String CreateUser(Model model, @ModelAttribute("newUser") User user) {
        this.userService.handleSaveUser(user);
}

##8 - Định nghĩa Repository Query##
Java Spring có cung cấp công cụ để tối ưu việc xây dựng nên các câu lệnh Query Gồm 3 bước: 
Bước 1: Tự định nghĩa tên của Method theo quy tắc 
Bước 2: Spring sẽ tự động chuyển "tên method" thành câu lệnh truy vấn database
Bước 3: nhận kết quả ra từ Repository

**tìm hiểu về keywords, mệnh đề quan hệ/điều kiện (And, Or, Before, After, Exist...) và method
https://docs.spring.io/spring-data/jpa/reference/repositories/query-keywords-reference.html
https://docs.spring.io/spring-data/jpa/reference/repositories/query-methods-details.html
Nhờ Bước 2 mà chúng ta có thể trả lời câu hỏi tại sao chỉ định nghĩa 1 abstract method nhưng khi chạy chương trình ứng dụng vẫn có thể kết nối xuống database (từ tên method được đặt theo quy tắc của Java Spring - Java Sping convert nó thành câu lệnh truy vấn xuống SQL) 

Để xem cách chuyển từ tên method -> câu lệnh truy vấn SQL thì cấu hình thêm trong file .properties 

Tạo Repository Query:
	khi ta dùng biến UserRepository có rất nhiều method được cung cấp mà chúng ta chưa định nghĩa là nhớ kế thừa CrudRepository trong lớp này Spring đã viết sẵn cho chúng ta. Nhưng nên chúng ta muốn viết method riêng -> tự định nghĩa câu lệnh Query 
	-> chung quy lại có thể tự định nghĩa ra Repository bất cứ ở đâu miễn là dùng class của @Repository
	**Tạo 1 abstract List<User> FindAll() trong Repository -> dùng ở Service -> lỗi 
	**Dùng trực tiếp FindAll() ở Service ko cần tạo trước List<User> FindAll() trong Repository -> ko lỗi
	** Những cái như FindByEmail, FindByEmailAndAddress -> thì có thể dùng ở Repository sau đó mới dùng qua service những cái này nó đã gởi ý sẵn cho ta bởi vì khi kế thừa JpaRepository<User, Long> ta có truyền User vào Spring sẽ vào đó và đọc những thuộc tính của ta đễ gợi ý 
	**Lưu ý: ta có Find...By ở đây ko có sự khác biệt bởi FindOneBy, FindBy, FindAllBy khi viết trong Spring còn để Spring phân biệt chúng thì nó sẽ dựa vào kiểu dữ liệu trả về là 1 object hay 1 List. mặc định những hàm này sẽ trả về List -> chung ta phải giới hạn phần tử trả về + phải kết hợp thêm điều kiện (như tìm cái đầu tiên) như dùng FindFirst lấy phần tử đầu tiên || FindTop1 (Top + number ở đây là số phần tử bị giới hạn)
Để chính quy bài bảng thì những Repository nên đặt ở Repository (abstract method) và sử dụng nó tường minh ở Service
	Nên đổi từ CrudRepository -> JpaRepository bởi vì đa số method cần thiết trong CrudRepository lại return ra Iterable khá khó sử dụng còn JpaRepository sẽ trả về List 

##9 - hoàn thành page /admin/user##
a) Load được tất cả dữ liệu của các user hiển thị lên page 
	- lấy dữ liệu -> gửi lên view -> dùng foreach để render ra dữ liệu
b) Sửa lại trang /admin/user/create khi bấm submit thì quay lại trang /admin/user
	theo tư duy thông thường thì chỗ return của function khi bấm submit sẽ redirect tới đơn giản ta chỉ cần chỉnh lại file .jsp của /admin/user -> nhưng đây chỉ hiển thị ra view và sẽ ko có data vì thực chất url nó sai và ko thể chạy được các câu lệnh load data lên như ban đầu 
	-> dùng redirect:url cần redirect tới lúc này khi return nó sẽ redirect tới cái function của cái url đó -> hoạt động của ứng dụng sẽ đúng

c) Tạo ra trang view detail khi bấm vào view của từng user sẽ hiện thông tin đầy đủ của họ 
	- phải lấy được Id của user được bấm vào nút view của từng người dùng 
		c1: dùng 1 form bao quanh những button đó sau khi submit sẽ xử lý - tuy nhiên ở đây dùng form tức là chúng ta gửi dữ liệu lên server - nhưng mà ở đây ta đơn giản chỉ truy vấn và xem dữ liệu của người dùng ko gửi bất cứ dữ liệu gì -> ko nên sử dụng cách này
		c2: dùng thẻ a và href và lúc render ra dữ liệu của từng user chỗ href ta sẽ chèn luôn user.id vào href="/admin/user/${user.id}" đây cũng sẽ là url ta xử lý dưới controller và ta sẽ lấy id đó ở controller = Annotation @pathVariable 
	
	
##10 - Tổng kết về mô hình MVC##
a) các thành phần tham gia 
	M: code trong thư mục Domain(theo domain-driven design nên ko đặt tên là entity hay models) models chịu trách nhiệm quản lý các "đối tượng/tác nhân" tham gia vào hệ thống, chính là các tables lưu trữ trong database (nhờ Annotation hỗ trợ của Spring mà có thể biến class thành các entity/tables) 
	V: code trong thư mục /webapp/WEB-INF/viewlà các file .jsp (html), tạo ra giao diện cho người dùng nhìn thấy
	C: code trong thư mục controller giúp điều hướng các yêu cầu của người dùng và cung cấp lại kết quả cho người dùng 
b) mối quan hệ giữa các thành phần 

url:../Users -> Controller <-> Services <-> Repository <-> database 
		    |
		   JSP (view)	
- khi người dùng gõ 1 đường link vào URL -> gửi 1 request lên server (java) "server sẽ quét qua tất cả controller để xem controller nào phụ trách nhận và xử lý request đó (1 function của controller)"
	+ nếu không cần lấy data -> controller trả về view - view render ra giao diện cho khách hàng thấy kết quả 
	+ nếu cần lấy data:
		controller sẽ gọi tới services (services là nơi chia nhỏ công việc từ controller) ở services sẽ ko kết nối trực tiếp tới database mà ở đây chúng ta dùng Repository pattern 
		services sẽ thông qua Repository để kết nối tới database (tách ra như này để chỉ có 1 lớp duy nhất kết nối trực tiếp tới database là repository -> dễ điều chỉnh và bảo trì)
		....
		sau khi lấy được data:
			repo trả về services
			services trả về controller
			controller ném data cho view 
			view sẽ render ra giao diện để người dùng thấy kết quả 

	
##11 - hoàn thành chức năng update, delete##
	Hàm save() -> java spring đã làm cho chúng ta nếu đã có user được save vào nếu đã có thông tin -> update 
										      chưa có -> create
	

====Phần 10 chapter 9 Project Thực Hành===

##1 - Nhìn lại kiến thức đã học:##
a) công nghệ đã dùng: 
	- sử dụng Spring boot để chạy dự án: 
		chính là @Annotation @SpringBootApplication trong class LaptopShopApplication.java 
		Nhờ Annotation này mà giúp chạy dự án - khởi tạo spring context, container - nạp và quản lý tất cả Beans 

		file .properties trong /resources giúp cấu hình dự án 

	- Sử dụng Spring MVC để thực hiện mô hình MVC: bên tron spring framework đã chứa sẵn Spring MVC 
		+ Model(entity)
		+ View(jsp)
		+ controller 
		**Hầu hết các Annotation để cấu hình MVC đã có trong springframework -> import vào sử dụng 

	- Spring Data(Hibernate/JPA) để mô hình hóa Model và kết nối với database: 
		+ Domain-driven design 	
		+ Repository pattern

b) Để phát triển dự án
	- Định nghĩa thêm Model(Spring data)
	- Viết logic theo mô hình MVC(Spring MVC)
	
##2 - Phân tích Yêu cầu thực hành##

Ý tưởng: có một trang web để hiển thị sản phẩm cho người dùng lựa chọn, các chức năng chính như sau: 
	- Hiển thị danh sách sản phẩm (home page)
	- xem chi tiết từng sản phẩm khi bấm vào 
	- Tìm kiếm sản phẩm theo tiêu chí nào đó 
	- Giỏ hàng
	- Mua hàng
	- ...
	Link tham khảo: https://fptshop.com.vn/may-tinh-xach-tay

3- Phân tích Models của bài toán 

Phân tích hệ thống cáo bao nhiêu người dùng - bao nhiêu actor 

Có 2 loại chính: 
- Người dùng chưa đăng nhập (guest) 
	Có thể: 
		Xem danh sách sản phẩm, xem chi tiết sản phẩm
		Tìm kiếm sản phẩm theo tiêu chí 
	Không thể: 
		Đặt hàng (vì cần thông tin người dùng)
		Thêm/sửa/xóa sản phẩm hoặc thông tin trên website 

- Người dùng đã đăng nhập (user)
Phân chia theo vai trò của người dùng 
	Vai trò của người dùng thông thường (user)
		Kế thừa lại tính năng của guest
		Có thể đặt hàng 
		Không có quyền Thêm/sửa/xóa sản phẩm hoặc thông tin trên website 
	
	Vai trò người dùng quản trị (admin)
		Kế thừa lại tính năng của user
		Full quyền trong hệ thống 

##4 - Phân tích thiết kế database##
Bước 1: Xác định các đối tượng tham gia vào hệ thống 
	Users		Roles(Vai trò của người dùng)		Products		Orders
"Chuẩn hóa dữ liệu: 1NF, 2NF, 3NF"
Bước 2: Xác định quan hệ giữa 
	Roles - User: 1 - N
	Order - Product: N - N
	Order - User: N - 1
	**Ở đây người dùng ko liên quan đến sản phẩm mà chỉ liên quan đến đơn đặt hàng 

**Associations: chia làm 2 hình thức
	+ Unidirectional(unique): quan hệ một chiều -----> là quan hệ giữa 2 table chỉ có 1 phía
	+ Bi-Directional: quan hệ 2 chiều ------ ràng buộc qua lại giữa 2 thực thể 
	Khi nói về 2 loại quan hệ này có thêm 2 keywords:
		The owning side: Bên sở hữu bên có foreign key
		Inverse side: bên ngược lại ko nắm cái gì cả (nơi sử dụng mappedBy)

	VD: Person =(1)<------ (0-1 onetoone)author
 	    Publisher(onetomany) (1)<------ (n manytoone)book	
	-> quan hệ 1 chiều ghi loại quan hệ ở 1 phía
	-> quan hệ nhiều 2 chiều ghi loại quan hệ 2 phía 
	Khi đọc mối quan hệ (đưa tên của bảng vào phía trước 1 mối quan hệ và đọc từ trái sang publisher one to many -> một nhà xuất bản thì có nhiều sách, book many to one nhiều sách được sx bởi 1 nhà xuất bản 
Tham khảo: https://docs.jboss.org/hibernate/orm/6.4/introduction/html_single/Hibernate_Introduction.html#associations

##5 - Các loại quan hệ vs code##
a) quan hệ one to many - many to one
Chúng ta có các Annotation:
	@ManyToOne(para)
	@OneToMany(para)
para: fetch=LAZY/EAGER(hăng hái) thiết lập khi chúng ta quan tâm đến hiệu năng 
	LAZY loading: khi nào cần tài nguyên chúng ta mới load nó lên -> hiệu năng cao 
	EAGER loading: ngay từ đầu đã load full tài nguyên -> hiệu năng ko cao

Ví dụ: Publisher(onetomany) (1)<------ (n manytoone)book
	Class Book {
		@ManyToOne(fetch=LAZY)
		Publisher publisher;
		//ở đây chúng ta dùng đối tượng để biểu thị mối quan hệ 
	}
	chúng ta sẽ không khai báo Long publisherId; ở đây vì theo OOP việc Join giữa 2 table với nhau thì ORM/Hibernate đã giúp chúng ta làm òi 
	
	Class Publisher {
		@OneToMany(mappedBy="publisher")
		Set<Book> books;
	}
	Ở đây chúng ta có thể dùng List nhưng set hiệu quả hơn ở 2 trường hợp:
		Không lưu trùng giữ liệu (List có thể trùng)
		Không cần lưu theo thứ tự (List lưu theo thứ tự)
	mappedBy sẽ định nghĩa @OneToMany(mappedBy="publisher") sẽ ứng với trường nào tại thực thể còn lại 
				Set<Book> books;
	mappedBy = "publisher" (phải đặt giống với tên đặt ở Book)

Users và Roles: N - 1
- Phân tích mối quan hệ
	1 user có 1 role và table_user có role_Id (owner side)
	
	User many to one role: nhiều user có thuộc role 
	@ManyToOne
	private Role role;
	//Nếu chỉ thiết lập đến đây khi chạy chương trình nó sẽ vừa tạo thêm 1 column role_id cho User vừa tạo ra một table mới role_user vì ở đây nó ko biết join 2 table như nào -> nó tự động tạo thêm table để join 2 table ở đó -> sẽ ko join trực tiếp 2 table với nhau 
	-> chúng ta phải chỉ chính xác đâu chính là nơi nối cái foreign key nối giữa khóa ngoại và khóa chính 
	-> Sử dụng mappedBy tại inverse side và @JoinColumn(name = "role_id") mục đích để ko tạo ra table role_user nữa mà giúp join trực tiếp giữa 2 table 

	@OneToMany(mappedBy="role")
	List<User> list;
	
	User many to one role: nhiều user có thuộc role 
	@ManyToOne
	@JoinColumn(name = "role_id") //nó sẽ giúp cho bảng User join trực tiếp với bảng role quan id của role 
	private Role role;
	**Bên nào xuất hiện @Many (là owner side ko cần mappedBy)
	
**Sử dụng mappedBy="" bên inverse side (bên @OneToMany)
	  @JoinColumn(name="") bên owner side (bên @ManyToOne) lúc này bên table của owner side sẽ có thêm 1 column name="" được thiết lập bởi JoinColumn 

b) quan hệ many to many 
	N - N = N - 1 + 1 - N
	Ví dụ: 
	Tutorials 		- 		tutorial_tag 		- 		Tags
	(tutorial_id)				(tutorial_id, tag_id)			(tag_id
	
	-> Nếu làm theo cách thông thường của Java Spring -> nó sẽ tự động sinh cho chúng ta 1 table đứng giữa gọi là Join Table (chứa 2 khóa ngoại mapping tới 2 khóa chính của 2 table còn lại - gọi là composite key: key dung hợp 2 khóa ngoại sẽ xác định thành 1 cặp key duy nhất) 
		
Nếu chúng ta làm thông thường mối quan hệ nhiều nhiều với java spring:
	Lưu ý: cả 2 table của chúng ta đều là owner side -> sử dụng Annotation mới là @JoinTable để nói với Java Spring biết là chúng ta dùng table nào đứng giữa để Mapping 2 đối tượng của chúng ta 
	class Tutorial {
		@ManyToMany
		@TableMapping(name = "tutorial_tag", 
			      joinColumns = {name = "tutorial_id"}, 
			      inverseJoinColumns = {"tag_id"})
		private Set<Tag> tags;
	}
	class Tag {
		@ManyToMany(mappedBy="tags")
		private Set<Tutorials> tutorials;
	}
	**Ở đây chúng ta có thể đổi chiều lại là Tag làm @TableMapping, Tutorial làm mappedBy nhưng khi làm chúng ta nên chọn 1 cái làm owner side và 1 làm inverse side mặc dù đây là quan hệ ngang hàng 

** Vấn đề phát sinh: 
	khi nó tạo table giữa nó chỉ có 2 trường là tutotial_id và tag_id mà thực tế ta muốn thêm 1 số trường thông tin khác nếu muốn thêm thì phải dùng Annotation @Embeddable ( tìm hiểu thêm )
	-> để giải quyết vấn đề theo các thủ công thì chúng ta sẽ tách mối quan hệ N - N ra làm 2 mối quan hệ: N - 1 và 1 - N 

** Cách làm N - N => N - 1 + 1 - N
Chúng ta sẽ tạo thêm 1 entity order_detail
public class OrderDetail {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    private long quantity;
    private long price;

    //order_id
    //product_id
}

Thiết lập mối quan hệ: 
- Quan hệ giữa Order và OrderDetail: Order has many OrderDetail (1-N)
	Order: one to many OrderDetail
	@OneToMany(mappedBy = "order")
	private List<OrderDetail> orderDetails;

	OrderDetail: many to one Order
	@ManyToOne
	@JoinColumn(name="order_id")
	private Order order
-> đây là quan hệ BiDirectional: quan hệ 2 chiều

- Quan hệ giữa OrderDetail và Product: OrderDetail has many Product (1-N)
	OrderDetail: many to one Product (nhiều OrderDetail có cùng 1 Product)
	@ManyToOne
	@JoinColumn(name="product_id")
	private Product product;
-> đây là quan hệ UniDirectional: quan hệ 1 chiều giữa OrderDetail và Product vì chúng ta chỉ cần xác định trong OrderDetail có Product nào điều ngược lại chúng ta ko cần thiết là 1 Product thuộc những OrderDetail nào 

##6 - Mối quan hệ One to One (1-1)##
ví dụ: post <----<> postDetail 
Một bài đăng chỉ có 1 bài đăng chi tiết ( một bài đăng chi tiết chỉ thuộc 1 bài đăng )
**Annotation @OneToOne và phải xác định Owner side (nơi sở hữu Foreign Key @JoinColumn(name="") 

Nếu làm bình thường 
post(id, title)
postDetail(id, createdOn, CreatedBy, pots_id)

@Entity(name = "Post")
@Table(name = "post")
public class Post {
 
    @Id
    @GeneratedValue
    private Long id;
 
    @OneToOne(mappedBy = "post", fetch = FetchType.LAZY)
    private PostDetails details;
}

@Entity
@Table(name = "post_details")
public class PostDetails {
 
    @Id
    @GeneratedValue
    private Long id;
 
    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
}

Cách tối ưu: chuyển khóa ngoại post_id -> khóa chính
post(id, title)
postDetail(pots_id, createdOn, CreatedBy)
class PostDetails {
	@Id
	private long id; 
	
	@OneToOne
	@MapsId
	private Post post;
}
ở đây chúng ta sẽ ko dùng cơ chế GenerateId nữa mà dùng @MapId để có thể biến khóa ngoại -> khóa chính (id của PostDetails -> Post_id)
	
	
=====Phần 12 Chapter 11: module upload file====
##1 - Design giao diện Admin:##

- clone https://github.com/hoidanit-be-java-spring-mvc/03-admin-template
- vào project của chúng ta tạo 1 controller để xử lý cho admin -> trang /admin
- vào tạo /view/admin/dashboard -> nơi lưu view của /admin tạo show_admin_page.jsp -> copy nội dung file index.html của template vào 

***trong template này cần chú ý file index.html có những link liên kết tỉnh để các css/js -> cần tạo những folder và file này tạo trong /webapp/resources -> sau đó vào config/WebMvcConfig.java để cấu hình lại nơi để dữ án load file css/js khi load file index.html sẽ tìm tới đường dẫn được cấu hình tới để tìm các file css/js cần thiết
***đổi các đường dẫn assets/demo/...js -> js/...js trong file show_admin_page.jsp và đưa tất cả file.js vào trong /js

##2 - Chia layout cho Admin Page(page giao diện cho các trang chức năng)##

##3 - Dùng JQuery làm chức năng Image Preview (xem ảnh khi upload lên)##

copy paste đoạn nào vào <head/> của create.jsp
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
		//đầu tiên import thư viện JQuery vào để code JQuery
                <script>
                    $(document).ready(() => {
                        const avatarFile = $("#avatarFile"); //lấy ra cái avatarFile
                        avatarFile.change(function (e) { //mỗi khi nó thay đổi
                            const imgURL = URL.createObjectURL(e.target.files[0]);
//lấy ra đường link URL, link này là 1 API browser đã làm sẵn -> nó sẽ cung cấp 1 url để hiển thị ảnh 
                            $("#avatarPreview").attr("src", imgURL); //gán URL đã lấy vào thuộc tính src của avatarPreview 
                            $("#avatarPreview").css({ "display": "block" });//thay đổi display của nó 
                        });
                    });
                </script>
-> những đoạn này chỉ xảy ra ở client front end, Java backend sẽ không làm được 

##4 - Nơi lưu trữ File##

a) Hình thức upload file
Có 2 hình thức upload file: single(upload 1 file/ 1 lần) và multiple (upload nhiều file / 1 lần)
- Khi upload multiple files:
	+ front end cần xử lý để truyền lên multiple files 
	+ back end cần xử lý để lưu nhiều files 1 lúc 
	+ vấn đề sẽ phát sinh nếu quan trọng thứ tự file upload 
(thường những file nhẹ sẽ đến server trước, nặng sẽ đến sau -> nếu chúng ta ko xử lý thứ tự file upload có thể dẫn đến các vấn đề phát sinh)

Để đảm bảo thứ tự của file upload -> upload từng file 1 (hiệu năng sẽ ko cao) để upload nhiều file = cách này có thể dùng vòng lặp cứ xong file này sẽ đến file khác (queue)

Nếu muốn upload nhiều file cùng 1 lúc -> phải cho nó chạy song song với nhau  


b) Nơi để lưu trữ file
- Hình thức 1: lưu trữ qua các dịch vụ online ví dụ: Amazon(S3), cloudflare(R2)
	Ưu điểm: truy cập mọi lúc mọi nơi. tự động backup giữ liệu
	Nhược điểm: pay as you go (dùng bao nhiêu trả bấy nhiêu, hoặc mua theo gói cước) 

**Các hình thức mà các ứng dụng ko cần trả phí thực hiện là đẩy dữ liệu về cho người dùng tự lưu trữ 
- Hình thức 2: lưu trữ file trong database 
	lưu trữ trong mySQL hỗ trợ định dạng blob và clob (khóa học sern trên ytb) 
	Ưu: miễn phí có thể lưu tối đa 4Gb/file
	Nhược: tốc độ IO chậm, phải tự backup 

- Hình thức 3: Lưu trữ tại server/lưu trữ tại nơi chúng ta viết code 
	Ưu: miễn phí, tốc độ IO nhanh hơn database (vì lưu raw file) 
	Nhược: tự backup dữ liệu, tối ưu hóa IO 

c) Cách thức lưu trữ hình thức 3
- Nguyễn tắc upload file: với hình thức lưu trữ file tại server (tức là lưu tại folder chứa source code/ hoặc folder local trên máy tính) 
	Bước 1: Client gửi file lên server (view)
	Bước 2: server lưu file vào folder quy định trước
	Bước 3: kiểm tra client có thể truy cập vào được file đã upload hay không (hiển thị ảnh ra view) 

d) Upload file với JSP 
- Sử dụng đối tượng MultipartFile để lấy file từ client gửi lên cho chúng ta 
- Logic để lưu trữ file:
	Chuyển file sang dạng bytes: byte[] bytes = file.getBytes(); -> Lưu trữ dưới dạng stream 
	Sau đó dùng BufferedOutputStream stream-> để tạo ra lại file khác giống với file ban đầu 
	sau đó dùng stream.write() để di chuyển file tới nơi lưu 

e) Hoàn thiện chức năng upload file (part1)
**nên convert lại tên file khi upload lên -> dưới dạng khác để tránh khi user upload nhiều file tên giống nhau 
**chúng ta chỉ cần lưu tên của file ảnh vào database ko cần lưu đường dẫn vì mình đã config nó nằm ở avatar/

Bước 1: mapping thêm Role (thuộc tính Object của User) 
Bước 2: Để có thể gửi file lên server -> thêm thuộc tính enctype="multipart/form-data" -> vì file ko thể gửi dưới dạng string lên server được mà cần được chuyển sang dạng binary -> tối ưu
Bước 3: thêm thuộc tính name cho <input type="file"> để server có thể thông qua đây lấy được dữ liệu (lưu ý chỗ này chỉ có thể dùng attr name ko dùng được id, class hay path của form:) 
Bước 4: lấy file ở server (controller) -> dùng Annotation @RequetsParam("nameFile") MutilpartFile[kiểu giá trị] file[tên biến] -> trong file này ở server nó sẽ có 1 attr value chứa thông tin file (là các số dữ liệu binary) khi đã được chuyển đổi
Bước 5: Lưu trữ file
	- cấu hình thêm trong file .properties 
	spring.servlet.multipart.max-file-size=50MB //dung lượng tối đa khi upload 1 file 
	spring.servlet.multipart.max-request-size=50MB //tổng request bao gồm all files khi gửi lên server 
https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties.web

h) Hoàn thiện chức năng upload file (part2)

hướng dẫn upload multiple file
	- ở thẻ input thêm attr multiple
	- @RequetsParan("nameFile") MutilpartFile[] file (dùng kiểu array ở đây)
dùng for lặp link hướng dẫn:
https://www.digitalocean.com/community/tutorials/spring-mvc-file-upload-example-single-multiple-files

https://spring.io/guides/gs/uploading-files

Giải thích code: 
public String CreateUser(Model model, @ModelAttribute("newUser") User user,
            @RequestParam("nameAvatarFile") MultipartFile avatarFile) {
        try {
            byte[] bytes = avatarFile.getBytes();
            String rootPath = this.servletContext.getRealPath("/resources/images");
            File dir = new File(rootPath + File.separator + "avatar");
            if (!dir.exists()) {
                dir.mkdirs();
            }
            // Create the file on server
            File serverFile = new File(dir.getAbsolutePath() + File.separator + System.currentTimeMillis() + "-"
                    + avatarFile.getOriginalFilename());
            BufferedOutputStream stream = new BufferedOutputStream(new FileOutputStream(serverFile));
            stream.write(bytes);
            stream.close();
        } catch (IOException ex) {
            System.out.println(ex);
        }
        // this.userService.handleSaveUser(user);
        return "redirect:/admin/user";
    }

byte[] bytes = avatarFile.getBytes();
- lấy hình ảnh dưới dạng binary
	
String rootPath = this.servletContext.getRealPath("/resources/images");
- đường link mình truyền vào là relative path -> câu lệnh này giúp lấy absolute path trên chính máy tính đang dùng 
ServletContext là lớp tổng quát được spring viết bọc cả Servlet - this.servletContext.getRealPath sẽ giúp chúng ta lấy đường link 
- thường 1 cấu trúc của 1 ứng dụng web sẽ có thư mục webapp khi build dự án nó sẽ lưu vào đây -> mặc định khi dùng this.servletContext.getRealPath("") -> mặc định trả ra địa chỉ chính xác đến thư mục webapp -> nó chỉ trả tới địa chỉ webapp chúng ta phải truyền thêm cho nó địa chỉ cụ thể muốn lưu vào cụ thể ở đây là /resources/images 	

File dir = new File(rootPath + File.separator + "avatar");
- tìm nơi nào chúng ta muốn lưu file chúng ta cộng chuỗi:
	địa chỉ tới images + "/" + tên thư mục nơi lưu

if (!dir.exists()) {
   dir.mkdirs();
}
- nếu thư mục đó chưa tồn tại ta sẽ tạo mới nó 

File serverFile = new File(dir.getAbsolutePath() + File.separator + System.currentTimeMillis() + "-"
                    + avatarFile.getOriginalFilename());
- tạo ra tên file chúng ta muốn lưu 
- dir.getAbsolutePath() + File.separator: đường link lưu trữ thư mục được check hoặc tạo ra bởi if ơ trên + "\"
- System.currentTimeMillis() + "-" + avatarFile.getOriginalFilename()); mili seconds + tên file: để sửa đổi tên file tránh trùng lặp
//cơ chế để tạo tên tránh trùng lặp trong 100 năm: uuid của Mongo DB 

BufferedOutputStream stream = new BufferedOutputStream(new FileOutputStream(serverFile));
dùng Buffer truyền vào file chúng ta muốn lưu 

stream.write() //lưu file

Stream.close() //để chống leak dữ liệu 

##5 - Các hình thức mã hóa data(Endcoding, hashing, encryption)##

a) Endcoding - Decoding (mã hóa - giải mã) 
	- Endcoding là quá trình chúng ta biến đổi data từ dạng này sang dạng khác
		Vidu: input: "hello world"
		      output: "101000010001"
		+ không sử dụng key/password nào để mã hóa (nhược điểm)
		+ có thể bị giải mã chuỗi đã được encoding 
		+ thông thường ko dùng để bảo vệ data 
		+ được dùng để compression(nén dữ liệu), Streaming 
		+ các định dạng sử dụng encoding: base64, .mp3, .mp4

b) Hashing
	Vidu: input: "hello world"
	      output: "333bef68dg8090q09302"
	Hashing là cách chúng ta băm  data thành 1 chuỗi string đặc biệt(hash)
	+ đây là quá trình 1 chiều ko thể giải mã 1 chuỗi đã được hash để lấy lại dữ liệu ban đầu
	+ Nên làm cho các data mang tính cần được bảo mật (password)
	+ Các bước: 
		Lúc đăng ký:
		Hash input đầu vào (băm dữ liệu nhập vào) thành 1 chuỗi ngẫu nhiêu
		sau đó lưu vào database 
		
		Lúc đăng nhập:
		Hash input đầu vào (băm dữ liệu nhập vào) thành 1 chuỗi 
		so sánh với chuỗi đó với chuỗi đã được lưu tron database 

c) Encryption
	vừa có Tính bảo mật cao hơn - vừa có tính 2 chiều (encoding - decoding)
	nâng cấp từ en-de coding được sử dụng để trao đổi dữ liệu 
	mục đích: để chúng ta mã hóa để gửi dữ liệu - giải mã để nhận dữ liệu 

	Nhược điểm: 
		Giới hạn về mặt dung lượng
		kế thừa những thuật toán phức tạp

	được áp dụng như messager (tin nhắn được lưu trữ trong db sẽ được mã hóa và khi sao lưu ra sẽ được giải mã)

d) Hash user password:
** Lưu ý: dữ liệu ở đây chúng ta chưa validate

đọc tham khảo về hashing: https://docs.spring.io/spring-security/reference/features/authentication/password-storage.html#authentication-password-storage-bcrypt

cách code: https://www.baeldung.com/spring-security-registration-password-encoding-bcrypt

code dependency injection thêm private final PasswordEncoder passwordEncoder vào UserController
	khi dùng passwordEncoder thì Spring security sẽ dùng thuật toán mặc định để hashing
	-> muốn dùng thuật toán BCryptPasswordEncoder để hash thì chúng ta ko thể dùng trực tiếp BCryptPasswordEncoder được cần phải overide lại PasswordEncoder để return về BCryptPasswordEncoder

	Muốn dùng cái này chúng ta phải khai báo dưới dạng Beans để ghi đè lên cấu hình mặt định của spring security dùng Bean để khi ứng dụng chạy lên thì nó dã ghi đè rồi 
	Phải cấu hình lại Spring security 

Tạo thêm SecurityConfiguration.java trong config để cấu hình Spring security
class này dùng 2 Annotation @Configuration, @EnableMethodSecurity(securedEnabled = true) để cho spring biết ta cấu hình spring security ở đây 
	Trong class này chúng ta cần khai báo BCryptPasswordEncoder dưới dạng Beans:
		  @Bean
		  public PasswordEncoder passwordEncoder() {
		        return new BCryptPasswordEncoder();
	          }
cấu hình xong chúng ta đã có thể sử dụng -> mật khẩu sau khi hashing có thể điều chỉnh ngắn dài = cách truyền tham số vào thuật toán BCryptPasswordEncoder

e)Lưu lại User vào database: 
- chúng ta còn thiếu rold_id trong bảng role -> view nó trả về 1 role_name 
-> chúng ta cần viết 1 service lấy role_id = role_name 

-> sau đó add đối tượng role tìm được khi lưu Spring data sẽ xử lý và chỉ lưu id của nó thôi 

g) Xử lý update(giống create) 

h) xử lý delete

====Phần 13 chapter 12 Module Product====

##1 - Design giao diện trang chủ##

a) Tạo giao diện cho "/" home page
- tạo 1 controller cho home page
- clone https://github.com/hoidanit-be-java-spring-mvc/04-client-template.git
- tạo 1 folder client bên trong webapp/resources để lưu tài nguyên của giao diện home page tránh trùng với admin
	** cấu hình thêm /client -> /resources/client
- copy all folder của template trừ folder scss (scss là cách viết css ngắn ngọn hơn bth và cần cấu hình trc mới đọc hiểu được spring chưa cấu hình ko đọc đc) vào client/

- đổi lại đường dẫn trong file .jsp 


b) Tạo Giao Diện cho Product Detail


c) Chỉnh sửa lại giao diện Product Admin

d) Valid dữ liệu (input đầu vào)
- Kiểm tra tính hợp lệ của dữ liệu -> Hạn chế dữ liệu rác 

- Nên validate ở Front-end hay Back-end
	Front-end: 
	Html: dùng các thuộc tính của các tag như type="", required, ...
	Javascript: validate trước khi gửi dữ liệu đi (đối với form khi bấm submit -> validate)
	-> Ưu điểm tăng trải nghiệm người dùng 
	-> Nhược có thể hack được -> thiếu sự bảo mật 

	Back-end: (server)	
	-> Tăng tính bảo mật (ko bị hack được)

- Validate với Java Spring
Cách 1: sử dụng jakarta.validation (Jakarta Bean Validation)
	Đây là cái tích hợp sẵn khi dùng mô hình MVC 
	Tài Liệu: https://beanvalidation.org/
	Ví dụ: https://spring.io/guides/gs/validating-form-input

	Cần 2 thư viện: 
	jakarta.validation
	org.springframework.validation.BindingResult
	
	Cần thêm thư viện: 
	<dependency> 
	    <groupId>org.springframework.boot</groupId> 
	    <artifactId>spring-boot-starter-validation</artifactId> 
	</dependency>	

	Spring đã giúp kết nối 2 thư viện này rồi chỉ cần sử dụng 
Cách 2: Sử dụng Hibernate Validator(thư viện ở ngoài) 
	Đa số trước giờ code dùng JPA chỉ dùng Hibernate để cấu hình vì hiện tại JPA đang giải quyết được vấn đề của ứng dụng chưa cần dùng tới Hibernate (Hibernate kế thừa JPA để phát triển thêm)

	Khi làm việc với session này tới backend -> sử dụng hibernate chứ hiện tại chúng ta mới chỉ dùng CRUD chỉ cần dùng JPA 
	Tài Liệu: https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#preface
	Ví dụ:  https://www.geeksforgeeks.org/hibernate-validator-with-example/
	Khi xem ví dụ đa số thư viện cài từ javax đây là version cũ -> nên dùng lại jakarta version mới 
	
	Lưu ý khi dùng Hibernate Validator cần cài thêm thư viện:
	<dependency>
	    <groupId>org.hibernate.validator</groupId>
	    <artifactId>hibernate-validator</artifactId>
	    <version>8.0.1.Final</version>
	</dependency>


**Trong ứng dụng này dùng cách 1 Jakarta.validation

##2 - Validate Model##

- Model User: 

Tài liệu: https://spring.io/guides/gs/validating-form-input

Bước 1: Decorate Model với annotation
https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html#builtinconstraints

<dependency> 
    <groupId>org.springframework.boot</groupId> 
    <artifactId>spring-boot-starter-validation</artifactId> 
</dependency>

Bước 2: Validate tại controller 
Trước hết cần vào domain vào entity cần valid dùng những Annotation như @Email, @min, @max vào những thuộc tính cần validdate
sau đó Để validate dữ liệu của 1 User trước khi lưu xuống data base ta cần đặt Annotation @Valid trước đối tượng User đó trong controller 

Bước 3: Get message lỗi sau khi được Validate dùng Annotation @Binding Result (sẽ hiển thị kết quả của quá trình Validate) cũng đặt trong tham số của controller xử lý @Valid và tham số bindingResult nameObjectBindingResult này cần đặt ngay sau tham số @Valid nếu ko sẽ ko trả ra kết quả mong muốn

@Binding Result   
https://stackoverflow.com/a/7384449

   List<FieldError> errors = nameObjectBindingResult.getFieldErrors();
    for (FieldError error : errors ) {
        System.out.println (error.getField() + " - " + error.getDefaultMessage());
    }
-> getField() sẽ hiển thị các trường bị lỗi khi có lỗi thì chương trình sẽ ko chạy bình thường được -> chúng ta cần return nó về lại /admin/product/create khi bị lỗi chứ ko redirect vì nếu rediretc nó sẽ mất thông báo lỗi mà nó load function của địa chỉ đó để chạy 
   if(nameObjectBindingResult.hasErrors()) return "/admin/product/create";

Bước 4: để hiển thị errors ra view JSP form cũng hỗ trợ cho chúng ta tag <form:errors path=""/> điền path của đối tượng cần kiểm tra 
	-> tag này sẽ tự generate 1 tag <span> để hiển thị lỗi

Đối với những tag của <form:> thì phải dùng thuộc tính của nó để generate ra lại 1 tag của html 
	ví dụ: <form:errors cssClass="error" /> 
	-> lên giao diện khi có error <span class="error"> </span>

để thêm hiệu ứng dùng Bootstrap 5: https://getbootstrap.com/docs/5.0/forms/validation/#server-side
Đối với span, thêm class “invalid-feedback” //mặc định display:none
Đối với input, thêm class “is-invalid” // thêm vào khi có lỗi 
Về error tags:
https://docs.spring.io/spring-framework/reference/web/webmvc-view/mvc-jsp.html#mvc-view-jsp-formtaglib-errorstag

https://docs.spring.io/spring-framework/docs/6.1.5/javadoc-api/org/springframework/web/servlet/tags/form/ErrorsTag.html

Check theo điều kiện có valid hay không ?
https://mkyong.com/spring-mvc/spring-mvc-form-check-if-a-field-has-an-error/

để thêm class is-invalid vào input khi có lỗi có 2 cách

Cách 1: dùng Annotation Spring:bind
Bước 1: thêm annotation đó vào (trước có thêm form rồi nên ko cần thêm form nữa)
  <%@taglib prefix="spring" uri="http://www.springframework.org/tags" %>

Bước 2:
 <spring:bind path="newUser.password"> //tên đối tượng . tên thuộc tính cần kiểm tra 
          <form:input type="password"
                class="form-control ${status.error ? 'is-invalid' : ''}"
                path="password" />
</spring:bind>
<form:errors path="password" cssClass="invalid-feedback" />

Nhờ Spring:bind chúng ta sẽ có biến status biến này sẽ trả ra true (có lỗi thêm class) hoặc false (ko)



Cách 2: dùng thư viện jstl/core đã cài sẵn dùng c: để sử dụng các function của jstl core 
	
     Gán giá trị cho 1 biến ở đây chúng ta set giá trị cho biến nameHasBindError = lỗi khi nhập sai pw
     <c:set var="nameHasBindError">
          <form:errors path="password" />
     </c:set>

     Kiểm tra cái biến nameHasBindError nếu nó có giá trị thì thêm class is-invalid, nếu ko có lỗi thì ko thêm
     <form:input type="password"
          class="form-control ${not empty nameHasBindError? 'is-invalid':''}"
          path="password" />

     <form:errors path="password" cssClass="invalid-feedback" />

Hoàn thiện Module Product: chỉnh sửa giao diện các ảnh ở phần admin bị bể và format giá tiền
	<%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt" %>
	
		
=====Chapter13: Module Auth (Session vaf Spring Security)=====

##1 - DTO (Data Transfer Object)##
- Trong form đăng ký thì có các trường như First Name, Last Name, Confirm Password -> mà trong Database ko có chỉ có Fullname và Password -> để xử lý trường hợp này t dùng DTO Design Pattern
- Sơ lược hoạt động của DTO: A (dữ liệu thô) - B (dữ liệu đã xử lý để lưu vào Database)
	Có thể thêm hoặc bớt data từ A để biến đổi nó thành B để phục vụ tốt cho nhu cầu của chúng ta
	Cụ thể ở đây: chúng ta tạo 1 class lưu trữ thông tin đăng nhập(Firstname, Lastname, email, Password, Confirm Password) 'thông tin này ko lưu vào Database' từ những thông tin này t chuyển đổi nó thành 1 User thông qua Mapper

- Mình có thể tạo 1 class khác để viết mapper nhưng ở đây để đơn giản thì ta viết mapper là một method trong các service luôn 


##2 - Validate dữ liệu##
- Thêm các file .java trong folder validate trong phần service
- Hiện tại: trong các domain chúng ta dùng cái Annotation của thư viện cung cấp cho chúng ta để valid dữ liệu
	+ Chúng ta có thể valid thủ công = code trong controller nhưng khuyết điểm là khó để đưa những lỗi này lên View 
	+ Ở các trang create, update ở Admin thì chúng ta chỉ dùng BindingResult nếu như có lỗi nó sẽ tự động ném lỗi qa View 
-> việc tự valid thủ công nếu dự án lớn sẽ rất piền -> chúng ta sẽ tự sẽ tự tạo ra các Annotation để valid theo nhu cầu 
- Tạo Annotation: 
	public @interface StrongPassword: đây là định nghĩa ra Annotation StrongPassword pải có @interface 
	@Constraint(validatedBy = StrongPasswordValidator.class) -> nói cho java biết là Annotation này làm gì 
	@Target({ ElementType.METHOD, ElementType.FIELD }) -> Phạm vi hoạt động của Annotation: trên 1 element, 1 class hay trên 1 method 
	@Retention(RetentionPolicy.RUNTIME) -> khi nào thì Annotation này chạy 
	@Documented: Cho phép annotation này xuất hiện trong tài liệu Javadoc.

	Cần các trường: 
		+ String massage() default "..." ->  Tin nhắn mặc định nếu ràng buộc bị vi phạm 
		+ class<?>[] groups() default {};
		+ class<? extend Payload>[] payload() default {};

- Giải thích: 
	+ @Constraint: Đánh dấu rằng đây là một annotation dùng để ràng buộc (constraint).
	+ Payload: Dùng để cung cấp thêm thông tin meta về constraint, thường để nhóm thông tin lỗi.
	
	+ các Annotation như Target, Retention, Documented là các Annotation Meta 
	
	@Constraint(validatedBy = StrongPasswordValidator.class)
	+ Liên kết annotation @StrongPassword với lớp StrongPasswordValidator, nơi logic kiểm tra sẽ được thực hiện.
	 

- Sau khi tạo Annotation ta cần định nghĩa nơi logic kiểm tra sẽ được thực hiện chính là phần Constraint valid = StrongPasswordValidator.class
	Class StrongPasswordValidator: 
		public class StrongPasswordValidator implements ConstraintValidator<StrongPassword, String> {

		    @Override
		    public boolean isValid(String value, ConstraintValidatorContext context) {
		        // check if string contains at least one digit, one lowercase letter, one
		        // uppercase letter, one special character and 8 characters long
		    return value.matches("^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=!*()]).{8,}$");
		    }
		}
	Để biến class StrongPasswordValidator thành 1 validator ta cần kế thừa lại ConstraintValidator những kiểu dữ liệu truyền vào này là những kiểu generate dùng template mình có thể truyền vào những kiểu dữ liệu bất kì 
		public interface ConstraintValidator<A extends Annotation, T> {
		   default void initialize(A constraintAnnotation) {
		   } 
		   boolean isValid(T var1, ConstraintValidatorContext var2); 
		}
	Ở đây: 
		+ initialize là 1 interface là default method ko cần kế thừa chỉnh sửa nó 
		+ isValid: cần kế thừa và chỉnh sửa nó sao cho phù hợp với mình validate viết override ở ngay trong class 	
			-> trả ra False nếu vi phạm nguyên tắc bạn đề ra - True ngược lại 
	StrongPasswordValidator
	-> nhưng nếu ta làm như thế này thì nó chỉ valid được cho từng trường dữ liệu thôi 
	-> để tối ưu code nhất thì chúng ta cần phải valid cho cả 1 class 
	@Constraint(validatedBy = RegisterValidator.class)
	@Target({ ElementType.TYPE }) // Adjusted to apply to the class level
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	public @interface RegisterChecked {

	    String message() default "User register validation failed";

	    Class<?>[] groups() default {};

	    Class<? extends Payload>[] payload() default {};
	}
	- Đầu tiên chỉ lại Target ElementType.TYPE để dùng Annotation này trang trí cho 1 class 
	- Tiếp theo cần sửa đổi lại logic chúng ta validate 
	public class RegisterValidator implements ConstraintValidator<RegisterChecked, RegisterDTO> {

    	@Override
    	public boolean isValid(RegisterDTO user, ConstraintValidatorContext context) {
        	boolean valid = true;

	        // Check if password fields match
        	if (!user.getPassword().equals(user.getConfirmPassword())) {
	            context.buildConstraintViolationWithTemplate("Passwords must match")
        	            .addPropertyNode("confirmPassword")
                	    .addConstraintViolation()
	                    .disableDefaultConstraintViolation();
        	    valid = false;
        	}

	        // Additional validations can be added here

        	return valid;
    	}
	- Giải thích code:
		context.buildConstraintViolationWithTemplate("Passwords must match") 
		//mỗi lần gặp lỗi thì báo ra lỗi Passwords must match
		addPropertyNode("confirmPassword")
		//trường thông tin báo lỗi là confirmPassword - mapping với View 

	- Để sử dụng Annotation này Vadlidate cho 1 class:
		+ đặt Annotation phía trên tên class
		+ dùng 2 Annotation Valid để kiểm tra dữ liệu và BindingResult để truyền lỗi qa View 
			Valid: khi mà String qét thấy 1 biến dùng Valid thì nó sẽ chạy vào trong domain của biến đó rồi xét xem có các ràng buộc/constraint Validate dữ liệu ko -> nó sẽ chạy vào các Annotation là Constraint để check -> nó sẽ check hàm isValid 
	
- Tiếp theo sau khi đã kiểm tra lỗi: 
	+ hiển thị ra View thông báo lỗi (dùng BindingResult để quăng qa View và dùng các thẻ Error để hiển thị)
	+ liên kết xuống database để check email (thêm Annotation Service cho Validator để thực hiện tiêm userService vào để lấy email từ database lên check)

##3 - Tổng quan về Spring Security##

a) enable Spring security lên: vào trang class main LaptopshopApplication.java
	@SpringBootApplication(exclude = org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class) //comment lệnh này 
	@SpringBootApplication mở lên này và để mặc định
	Ở đây nếu mở SpringBootApplication lên thì nó sẽ không hoạt động được vì:
		- thứ nhất chúng ta đã cấu hình lại ở phần config mã hóa Password -> cần phải chỉnh password trong file properties = mã hóa theo chuẩn đã cấu hình 
		- và 1 số lý do khác :vvv
	khi enable nó lên thì khi truy cập vào app cần login và trang login này sẽ ghi đè lên /login đang custom

b) chúng ta cần back code lại trước đó để kiểm tra luồng hoạt động mặc định của Spring Security
Mô hình hoạt động của Spring Security trong việc đăng nhập = trang mặc định /login và tài khoản thì tự cấu hình trong .properties: 
	1 - nhập và submit thông tin tài khoản từ giao diện (form)
	2 - Thông tin này sẽ được Spring Security đưa qa các Filter Chains mặc định để kiểm tra về thông tin người dùng thì sẽ có qua UsernamePasswordAuthenticationFilter trong class filter này cần nhận về 1 Authentication -> để lưu nó vào SecurityContextHolder (đây là nơi để xác thực việc đăng nhập)
	(muốn có authentication -> thì cần lấy được dữ liệu thông tin user đã có lên so sánh với dữ liệu đầu vào)
	(nhưng dữ liệu của chúng ta có nhiều hình thức lưu trữ như là lưu ở memory/RAM, database, bên thứ 3, ...)
	-> Spring Security cung cấp nhiều phương thức để lấy dữ liệu như: 
		DaoAuthenticationProvider(nếu lưu dữ liệu ở database hoặc memory/RAM)
		LdapAuthenticationProvider 
		OpenIdAuthenticationProvider 
		JwtAuthenticationProvider 
		...
	tất cả những class này kế thừa interface AuthenticationProvider
	và để Spring xác định được đối với mỗi dự án thì dùng phương thức để lấy dữ liệu nào -> Spring dùng các class kế thừa từ AuthenticationManager như class ProviderManager

	2.1 - Trong UsernamePasswordAuthenticationFilter sẽ gọi đến ProviderManager ở đây sẽ tạo ra một vòng lặp lặp qa tất cả các Provider xem Provider nào hợp với cấu hình của dự án và trả ra 1 Provider hợp lý đối với dự án 

	2.2 - Sau khi có Provider rồi thì để kết nối xuống database ở đây thì cho mọi Provider Spring Security cùng cấp 1 interface UserDetailsService trong này sẽ có: các class kế thừa nó như
		InMemoryUserDetailsService(nếu chúng ta ko cầu hình thì nó sẽ chọn cái này làm mặc định tức là lấy dữ liệu qua Ram/dữ liệu lưu trong code tức là account config trong .properties)
		LdapUserDetailsService
		....
		hoặc là CustomUserDetailsService(loại người dùng tự kế thừa lại UserDetailsService và custom nó)
		Đặc biệt trong Interface này chỉ có 1 method là loadUserByUsername() chúng ta cần custom cái method này sao cho hợp với dự án của chúng ta với:
			input: username nhập vào ở view
			output: UserDetails ở đây nó sẽ trả về cho Provider gọi nó (trong này lưu thông tin như password)
	2.3 - cuối cùng là việc so sánh password Spring Security cung cấp 1 interface PasswordEncoder sẽ có 1 class kế thừa nó và được init khi đã lựa chọn ra được 1 Provider 
		input: UserDetails (bao gồm password đã bị mã hóa theo dự án hiện tại thì mã hóa theo BCryptPasswordEncoder chúng ta đã override sơ lại cái PasswordEnconder trong phần config) và password lấy từ phía người dùng nhập vào 
		output: Authentication Object trả về lại cho Filter UsernamePasswordAuthenticationFilter
	3 - Khi UsernamePasswordAuthenticationFilter có data là authentication -> thì nó sẽ lưu data này vào 
	SecurityContextHolder
		SecurityContext
			Authenticaion(user data: username, permission, ... ở đây ko lưu password)
	và sẽ chèn dữ liệu này vào SecurityContextHolderFilter để thực hiện kiểm tra người dùng 

Sau khi xong quá trình login của Spring Security có 2 trường hợp xảy ra: 
	- Mỗi lần người dùng F5/refresh lại hệ thống tức là chúng ta gửi 1 request mới đến server -> thì Spring Security sẽ ko chạy lại all bước tùy theo cơ chế mà người dùng cấu hình như dùng Session thì nó sẽ vào kiểm tra SecurityContextHolderFilter đối với filter này sẽ kiểm tra bên trong SecurityContextHolder có lưu thông tin người dùng đăng nhập không nếu có thì người dùng sẽ tiếp tục sử dụng không cần phải đăng nhập nữa 
	- Trường hợp sai thông tin đăng nhập
		sẽ dùng ExceptionTranslationFilter filter này sẽ có trách nhiệm báo lỗi lại cho coder

Chung quy lại: thì tất cả các phần Java Spring đã làm sẵn cho chúng ta rồi ta chỉ cần kế thừa và custom cách query kết nối xuống database ở UserDetailsService hoặc nâng cao hơn là tự viết 1 Filter ko dùng Filter mặc định của Spring Security 

c) tiến hành thực hiện trên code = chế độ Debug để xem quá trình chạy 
Ở đây sẽ chạy chế độ debug ở những class trong thư viện của Spring Security  
Mở nhanh file (đã compiled) với VSCode:
nhấn Ctrl + T
- đầu tiên khi nhập dữ liệu vào Form login và nhấn submit -> Spring Security sẽ bắt đầu đưa dữ liệu qua các Filter
Thứ tự các file class cần debug:
1 - UsernamePasswordAuthenticationFilter(đặt breakpoint dòng 35)
	trong class này để ý attemptAuthentication() hàm này sẽ trả về 1 biến authenticate 
		return this.getAuthenticationManager().authenticate(authRequest);
		nhấn ctrl bấm vào authenticate nó sẽ dẫn đến Interface AuthenticationManager

2 - AuthenticationManager
	đây chỉ đơn giản là 1 interface có phương thức authenticate chúng ta cần đi đến class implement interface này và override method đó để hoạt động 
	bấm chuột phải vào class AuthenticationManager và chọn "go to implementations" chọn class ProviderManager

3 - ProviderManager(đặt breakpoint tại hàng 66)
	trong class này để ý method override là authenticate() ta có 1 vòng lặp để lặp qua tất cả các Provider và trả ra Provider phù hợp với cấu hình dự án hoặc đưa dữ liệu vào Provider đó luôn 
	do chúng ta dùng username, password để đăng nhập kết hợp với database nên nó sẽ chạy vào DaoAuthenticationProvider

4 - DaoAuthenticationProvider(đặt breakpoint dòng 53)
	trong class này để ý method retrieveUser() trong này sẽ gọi đến Service (UserDetailsService) nó sẽ gọi đến method duy nhất của Service này là loadUserByUserName(username) 
	khi click vào loadUserByUserName nó sẽ dẫn đến Interface UserDetailsService
	-> chúng ta cần đến class kế thừa và override phương thức này và đối với dự án của chúng ta chưa cấu hình gì hết mà chỉ mới cài Spring Security thì mặc định nó sẽ dùng class InMemoryUserDetailsManager

5 - InMemoryUserDetailsManager(đặt breakpoint dòng 123)
	bên trong này nó cần viết logic để query dữ liệu
	chú ý hàm loadUserByUsername() -> trả ra UserDetails Object (data là gồm thông tin người dùng - username, pw)
	sau khi có data rồi thì Spring Security sẽ chạy vào SecurityContextHolderFilter 

6 - SecurityContextHolderFilter(đặt breakpoint dòng 40)
	chú ý hàm doFilter() giúp set context/thông tin người dùng vào đây (thông tin này đã bỏ qua pw)
	có 1 biến để lưu dữ liệu deferredContext ban đầu nó sẽ load từ Request từ client để kiểm tra giá trị của biến này thì dùng deferredContext.get() vì nó có kiểu dữ liệu Supplier đây là 1 interface chỉ có 1 method Get

Watch variable: bấm dấu + và thêm dữ liệu này vào để kiểm tra nó
	deferredContext.get()
		chứa authentication

Sau khi đặt all tiến hành chạy ở chế độ Debug: 
	1 - truy cập vào Url nó sẽ chưa hiển thị lên trang login vì Spring Security đầu tiên nó sẽ chạy vào SecurityContextHolderFilter để kiểm tra có data (người dùng đã đăng nhập và chưa logout trước đó chưa) nếu có thì nó sẽ bỏ qua login mà vào trang chủ luôn 
		ban đầu deferredContext.get() chứa authentication = null
	2 - sau khi nó kiểm tra trong đó xong nếu authentication = null nó sẽ hiển thị lên trang login 
	
	3 - sau khi nhập thông tin và nhấn submit nó vẫn sẽ chạy vào SecurityContextHolderFilter đầu tiên sau khi check authentication = null nó sẽ chạy vào UsernamePasswordAuthenticationFilter
	
	4 - trong UsernamePasswordAuthenticationFilter nó có gọi đến method authenticate() của ProviderManager(kế thừa và override từ interface AuthenticateManager) 
		trong này nó sẽ có 1 vòng lặp để kiểm tra chúng ta dùng Provider nào ứng với việc mà mình login ở đây chúng ta dùng username và password cũng ko dùng third party -> sau khi chạy xong vòng lặp nó sẽ chạy vào DaoAuthenticationProvider

	5 - trong DaoAuthenticationProvider nó sẽ chạy vào method retrieveUser ở đây nó sẽ gọi đến Service (UserDetailsService) nó sẽ gọi method loadUserByUsername ở đây chúng ta ko cấu hình database nên mặc định nó sẽ chạy đến class InMemoryUserDetailsService nơi kế thừa và override lại loadUserByUsername

	6 - trong InMemoryUserDetailsService có loadUserByUsername được override -> trả về thông tin của User (UserDetails)
	
	7 - Sau khi có UserDetails trả về cho UsernamePasswordAuthenticationFilter rồi + password được lấy từ login -> PasswordEndcoder để mã hóa password và so sánh -> rồi trả về authentication

	8 - từ đó chúng ta đã có data -> SecurityContextHolderFilter để lưu data lưu vào trong deferredContext nó chứa 
		authentication: 
			trạng thái authenticated: true
			quyền hạn  user authorities: ở đây là 1 array nếu ko có cầu hình thì length = 0
			credential = null (password của người dùng)
			details chứa:
				địa chỉ 
				session sau này nếu dùng session nó sẽ lưu vào đây
			principal là id của người dùng 
				username = ...
				password = null
				....
-> hoàn thành việc đăng nhập và trở về trang chủ - ở đây nếu chúng ta refresh lại trang chủ thì nó sẽ chạy vào SecurityContextHolderFilter để kiểm tra ngay bây h trong context nó có lưu session(mặc định)/thông tin người dùng không -> bỏ qua phần login 

d) Custom logic ở loadUserByUsername giúp login với Spring Security 
1 - Mở Spring Security lên 
	cmt đoạn code này:
// @SpringBootApplication(exclude = org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class)
	Dùng code này:
@SpringBootApplication

2 - Khi đã enanle Spring Security -> chạy chương trình vào bất kì Url nào nó cũng sẽ redirect về trang login mặc định của Spring Security 

3 - Custom lại luồng đăng nhập 
	- Bên trong phần Config Security đang override lại passwordEnconder để băm password -> BCryptPasswordEndcoder -> chúng ta cần phải nói cho Spring Security dùng cái này để hash password
	- Chỉnh lại không cho nó lấy dữ liệu mặc định InMemory (lấy tài khoản được config trong .properties) -> mà cấu hình lại để nó lấy từ Database 
	
	- Chúng ta sẽ viết logic lại cho UserDetailsService đây là 1 Interface -> kế thừa lại nó để ghi đè lại cấu hình mặc định (là chuyển từ dùng InMemory -> database)
	Tạo 1 class CustomUserDetailsService trong Service implements UserDetailsService và Override lại abstract method của nó 
	@Override
	    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        
	    }
	Function này yêu cầu chúng ta trả ra 1 UserDetails nhưng đối với dự án này chỉ có thể Return về User (class tự tạo ra)
	
	Tìm hiểu về interface UserDetails extends Serializable gồm các trường: 
		Collection<? extends GrantedAuthority> getAuthorities();
	   	String getPassword();
   		String getUsername();
   		boolean isAccountNonExpired();
   		boolean isAccountNonLocked();
	   	boolean isCredentialsNonExpired();
   		boolean isEnabled();
	đây là 1 Interface ko hề có hàm tạo chúng ta cần tìm lớp con kế thừa nó để return về lớp con đó ở Function loadUserByUsername -> nó sẽ tự ép kiểu về UserDetails (Up casting)
	-> bấm chuột phải vào interface + 'go to implementations' -> có class User (đây là class của Spring Security)
	class User implements UserDetails, CredentialsContainer gồm: 
	private String password;
   	private final String username;
   	private final Set<GrantedAuthority> authorities; //quyền, set sẽ đảm bảo các giá trị là độc quyền
	private final boolean accountNonExpired;//tài khoản hết hạn hay chưa
   	private final boolean accountNonLocked;//tài khoản có bị khóa không
   	private final boolean credentialsNonExpired;//mật khẩu hết hạn chưa (kiểu bao nhiêu tháng đổi mk 1 lần)
   	private final boolean enabled;//tài khoản có kích hoạt chưa 
	... (một số thông tin phục vụ cho nhiều loại dự án khác nhau)
	Và nó có hàm tạo để tạo ra 1 class này 
	public User(String username, String password, Collection<? extends GrantedAuthority> authorities) {
      		this(username, password, true, true, true, true, authorities);
	}
	-> có một số thông tin khá trùng với User tự tạo -> truyền dữ liệu từ User tự tạo vào đây để Return về 1 User của hệ thống để nó tự Ép kiểu về UserDetails 
	Có 1 vấn đề là bây h có 2 class trùng tên User -> 1 User của hệ thống sẽ được import vào User tự tạo sẽ gọi trực tiếp tên package: vn.hoidanit.laptopshop.domain.User user = this.userService.fetchUserByEmail(username);
	username ở đây thì nó sẽ lấy từ Form login -> khá hiệu quả linh hoạt mỗi hệ thống sẽ có mỗi username khác nhau như sdt, email, ... đối với dự án này thì t dùng email 
	Return về giá User của Spring Security có các thông tin của User tự tạo:
	        return new User(user.getEmail(), user.getPassword(), Collections.singletonList(new 	SimpleGrantedAuthority("ROLE_USER")));
	Vì constructor của User(Spring) chỉ cần truyền vào username, password và quyền của người dùng
	Với quyền của người dùng là 1 collection<'template/generate' GrantedAuthority> trong này chỉ cần truyền vào class kế thừa từ GrantedAuthority bấm vào thì thấy nó chỉ yêu cầu dữ liệu truyền vào là 1 chuỗi String 

	Khi đã custom xong cái UserDetails service = CustomUserDetailsService -> cần nói cho Spring biết ta dùng cái Service này thay cho UserDetailsService mặc định + sử dụng hình thức hash code trong config Security:
	- Nếu dùng version 5.7 trở xuống thì cần kế thừa lại WebSecurityConfigerAdapter còn version hiện tại thì làm việc với Bean/component -> ko cần kế thừa
	- vào config Spring Security: 
    @Bean
    public UserDetailsService userDetailsService(UserService userService) {
        return new CustomUserDetailsService(userService);
    }
   	Giải thích code: đoạn code này sẽ ghi đè lại UserDetailsService mặc định của Spring Security = CustomUserDetailsService thông qua việc return lại CustomUserDetailsService việc truyền userService vào là vì trong CustomUserDetailsService cần userService(service tự tạo) để truy vấn xuống csdl

	Ở đây chúng ta đã nói với nó hash password và userdetailsService -> h lắp ráp chúng lại là thông báo cho spring Security ứng với việc login chúng ta pải làm như thế nào -> ghi đè lại authenticationManager để xâu chuỗi các hoạt động lại 

    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http, PasswordEncoder passwordEncoder,
            UserDetailsService userDetailsService) throws Exception {
        AuthenticationManagerBuilder authenticationManagerBuilder = http
                .getSharedObject(AuthenticationManagerBuilder.class);
        authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
        return authenticationManagerBuilder.build();
    }

	Giải thích code: nạp tất cả các phần chúng ta custom vào đây để gửi đến các class cần sử dụng chúng như passwordEncoder sẽ gửi cho DaoAuthentication... chứ ko pải của AuthenticationManager ... 
	
e) Hiện tại bị lỗi: khi nhập sai mật khẩu nó sẽ chạy vào vòng lặp vô tận -> Fix
- Bỏ phần code này trong config Security: vì cái Bean này nó bị mâu thuẫn với Spring Security
    @Bean
    public AuthenticationManager authenticationManager(HttpSecurity http, PasswordEncoder passwordEncoder,
            UserDetailsService userDetailsService) throws Exception {
        AuthenticationManagerBuilder authenticationManagerBuilder = http
                .getSharedObject(AuthenticationManagerBuilder.class);
        authenticationManagerBuilder.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder);
        return authenticationManagerBuilder.build();
    }

- Thay bằng: 
    @Bean
    public DaoAuthenticationProvider authenticationProvider(PasswordEncoder passwordEncoder,
            UserDetailsService userDetailsService) {
        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        daoAuthenticationProvider.setUserDetailsService(userDetailsService);
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder);
        daoAuthenticationProvider.setHideUserNotFoundExceptions(false);
        return daoAuthenticationProvider;
    }
	Ở đây chúng ta dùng trực tiếp DaoAuthenticationProvider để override trực tiếp lên UserDetailsService và PasswordEncoder mà DaoAuthenticationProvider này sử dụng chứ ko thông qua AuthenticationManager
	 daoAuthenticationProvider.setHideUserNotFoundExceptions(false); câu code này giúp hiển thị lỗi trong CustomUserDetailsService của chúng là là câu "User is not found" dòng 25 -> khi bạn nhập sai email + mật khẩu sai 
	-> nếu nhập đúng email mà sai mật khẩu nó mới hiện Bad Creditail -> giảm bảo mật
	Nếu để mặc định thì dù nhập đúng hay ko đúng email hoặc mật khẩu nó luôn hiển thị câu lỗi mặc định là Bad Credential -> như thế này sẽ an toàn cho hệ thống hơn 

Tiếp theo để đọc phần log trực tiếp xem hoạt động hay lỗi gì ở Spring Security ở terminal thì thêm vào trang properties:
	loggin.level.org.springframework.security=DEBUG

f) Lưu ý về lỗi Malicious String "//":
- Cần chạy lại chương trình và đọc log lỗi
- khi enable Spring Security -> phải code theo chuẩn của nó để đảm bảo an toàn 
- chỉnh lại ở các controller khi return về địa chỉ của file jsp return "admin/user/create"; ko nên return "/admin/user/create"; vì mình đang đứng ở templates -> nên dùng địa chỉ tương đối nếu ko kích hoạt Spring Security lên nó sẽ bị lỗi 
vì bên trong config WebMVCConfig mình có cấu hình mỗi lần đọc file view -> chạy vào /WEB-INF/view/
-> nếu return "/admin/user/create" -> nó sẽ chạy vào /WEB-INF/view//admin/user/create -> lỗi 


g) tiếp tục đặt và chạy dưới dạng Debug để xem cách hoạt động như so sánh password ở đâu và những trường thông tin lấy vào nó dùng ở đâu ? 
- Đặt breakpoint: 

	1 - DaoAuthenticationProvider: đặt tại dòng 53 trong hàm retrieveUser 
		function này chỉ đơn giản là return ra user mà load được tại loadUserByUsername nhưng ko biết được ai gọi đến function này (bấm chuột phải vào function này + go to declare đi đến function định nghĩa/dùng nó) là 1 abstract class AbstractUserDetailsAuthenticationProvider 
	
	2 - AbstractUserDetailsAuthenticationProvider: tại hàm authenticate() đây là hàm xử lý khi bạn nhấn submit sau khi điền thông tin đăng nhập vào form trong đó có 1 đoạn if else để check tài khoản user sai -> throws Bad credentials trên giao diện
	this.preAuthenticationChecks.check(user); để check user pre ở đây ý nghĩa là thực hiện cái này trước khi làm gì đó 
	mình bấm tiếp vào hàm check -> ra 1 interface UserDetailsChecker -> đi tới class kế thừa override nó (chuột phải vào + go to implementations) -> AbstractUserDetailsAuthenticationProvider$DefaultPreAuthenticationChecks đây là class override lại hàm check:
		ở đây nó sẽ kiểm tra các thông tin trong 1 biến UserDetails như:
			boolean isAccountNonExpired();
	   		boolean isAccountNonLocked();
		   	boolean isCredentialsNonExpired();
   			boolean isEnabled();
		để kiểm tra tình trạng của tài khoản khi mình return 1 User(Spring Security) -> nên dùng hàm khởi tạo mặc định của nó để set những biến này = true -> pass qua cái kiểm tra này nếu ko nó sẽ bị lỗi đăng nhập 
	Sau khi check tình trạng tài khoản thì nó đến check password 
	this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);
	đi đến class override lại method này cũng chính là DaoAuthenticationProvider ở class này nó override lại và tiến hành so sánh password 
	Lấy password từ trang login và nó hash code theo PasswordEncoder:
		String presentedPassword = authentication.getCredentials().toString(); 
	Lấy password từ UserDetails
		userDetails.getPassword()
	và thực hiện so sánh 
	tiếp tục mình đặt breakpoint ở dòng 38 DaoAuthenticationProvider hoặc trong cái if (nhưng pải đặt mật khẩu sai nó mới chạy vào)

	3 - SecurityContextHolderFilter: đặt breakpoint tại dòng 40 trong hàm doFilter()
	+ thêm Variable cho phần Watch: deferredContext.get() 
	Kiểm tra sau khi login thành công dữ liệu của người dùng được lưu vào đâu 



h) Chuyển đổi trang login sau khi đã hoàn thành luồng hoạt động thành trang login của dự án + một số trang ko cần login 
1 - Muốn chuyển đổi trang login -> phải biết cách thức hoạt động của nó -> inspect trang của nó xem form
- Có 3 trường thông tin: (3 name của 3 thẻ input trong form)
	username, password
	_csrf

- Sơ lược vè CSRF attack
đây là loại tấn công về an toàn thông tin: Spring sử dụng 1 cơ chế gọi là Session để lưu trữ session thì nó đang sử dụng cookies với cơ chế của cookies mỗi một lần vào website khác -> brower mặc định nó sẽ gửi kèm cookies -> để tránh trường hợp này mỗi một lần người khác vào website -> thì server sẽ generate ra 1 token lưu vào input="_csrf" này -> hacker gọi đến server của người dùng nếu ko có name=token của thẻ input="_csrf" này sẽ ko hack được token này được Java Spring tự tạo 
Csrf token: token ứng với lượt truy cập web của user. Cần token này để phòng tránh CSRF (Cross Site Request Forgery) . Hiểu một cách đơn giản, là tăng độ an toàn cho website của bạn
https://www.youtube.com/watch?v=m0EHlfTgGUU
Csrf token:
https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html#csrf-integration-form
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>

-> đối với form login của Java Spring cần thêm 1 thẻ input chứa token này 
Cấu hình mặc định của trang login: 
https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/form.html

2 - Chỉnh sửa trang login: 
	<form action="/login" method="post">
	<input class="form-control" id="email" type="email" placeholder="name@example.com" name="username" />
	<input class="form-control" id="password" type="password" placeholder="Password" name="password" />
	Nếu để name của email = email luôn -> chúng ta cần cấu hình thêm 

	thêm: có thể bỏ vào 1 div 
	<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>

3 - cấu hình lại config để chuyển trang login 
- tìm thử trang login nó cấu hình ở đâu 
	tìm class SpringBootWebSecurityConfiguration trong này có 1 method defaultSecurityFilterChain có câu lệnh 
	http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated()); câu này sẽ giúp xác thực/login đối với tất cả request từ client 
	http.formLogin(withDefaults()); form login dùng default -> muốn customize form login cần phải điều chỉnh chỗ này 
	http.httpBasic(withDefaults()); // đây là dạng đăng nhập = JSON web token || form basic ko dùng trong dự án này 
- Ghi đè lại cái method SecurityFilterChain - cũng phải tạo 1 Bean vì SecurityFilterChain là 1 Bean vào config Security
	@Bean
        SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
      	  	http.authorizeHttpRequests(authorize -> authorize.anyRequest().permitAll())
        	.formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("/login/?error").permitAll());
	        return http.build();
        }
	Giải thích code: viết code từ version > 6 và dùng lamda 
	1 - http.authorizeHttpRequests(authorize -> authorize.anyRequest().permitAll())
	câu này đang đi ngược lại với Spring Security tức là bên trên mặc định mọi request đều cần đăng nhập nhưng cầu này mọi request đều ko cần đăng nhập qua .permitAll()
	
	2 - .formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("login/?error").permitAll());
	khi login phải vào url /login khi login fail redirect về login/?error và ai cũng có quyền vào trang login này 

-> Lúc nay khi chạy chương trình chúng ta có thể vào all các Url khi đổi lại: http.authorizeHttpRequests(authorize -> authorize.anyRequest().authenticate()) thì chạy vào url nó sẽ bị lỗi: localhost redirected you too many times.

	Vào xem phần log chúng ta sẽ thấy lỗi: 
	Get /login
	Get /WEB-INF/view/client/auth/login.jsp ?? tại sao có url này trong khi mình dùng url /login cho view 
	hoặc nó yêu cầu Initializing Servlet 'dispatcherServlet'
	Thực tế lỗi này chỉ có ở Spring MVC chứ nếu dùng JSON web token sẽ ko gặp 

	Lý do lỗi: vào controller 
	-> khi chúng ta vào login -> chạy tới GetMapping("/login") function chỗ này sẽ return về "client/auth/login" 
	-> với cấu hình trước đó thì nó sẽ trả về /WEB-INF/view/client/auth/login.jsp chỗ return này chúng ta đang forward lời gọi mặc định từ version 6.0 trở đi thì những lời gọi forward sẽ bị chặn -> ta cần cấu hình lại mở nó ra không thì page sẽ bị vòng lặp vô hạn nó sẽ cứ redirect 
	Tức là khi chúng ta vào trang /login thì sẽ gọi đến file view -> Spring sẽ xem đây là lời gọi chuyển tiếp 
	theo hướng dẫn:
https://stackoverflow.com/a/75223368
https://docs.spring.io/spring-security/reference/5.8/migration/servlet/authorization.html#_permit_forward_when_using_spring_mvc

	Cấu hình thêm: 
    @Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests(authorize -> authorize
                .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.INCLUDE).permitAll()
                .requestMatchers("/", "/login", "/client/**", "/css/**", "/js/**", "/images/**").permitAll()
                .anyRequest().authenticated())
                .formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("/login/?error").permitAll());
        return http.build();
    }
	Giải thích code: lưu ý code sẽ được chạy từ trên xuống 
	1 - .dispatcherTypeMatchers(DispatcherType.FORWARD, DispatcherType.INCLUDE).permitAll()
		- DispatcherType.FORWARD cho phép/mở việc khi truy cập vào 1 url -> cho phép forward tới 1 file đường dẫn tới view ví dụ url:localhost:8080/login -> vào controller -> return /WEB-INF/view/client/auth/login.jsp cho phép điều này 
		- DispatcherType.INCLUDE: nếu ta bỏ cái này thì vào bất kì url nào có truy cập đến thành phần khác như Service(gọi đến database hoặc cái gì đó khác) ngoài return 1 đường dẫn render ra view thì spring sẽ chặn lại và page đó sẽ ko load được trang và trong log nó sẽ hiện lỗi denied access 

	Mặc định trong DispatcherType Spring sẽ chặn 2 loại FORWARD và INCLUDE ngoài ra còn có REQUEST, ASYNC, ERROR kể từ Version 5.8 
	
	2 - .requestMatchers("/", "/login", "/client/**", "/css/**", "/js/**", "/images/**").permitAll()
	khai báo tất cả các đường dẫn được phép public ra ngoài ở đây ai cũng truy cập được
	
	3 - .formLogin(formLogin -> formLogin.loginPage("/login").failureUrl("/login/?error").permitAll());
	trang đăng nhập dùng url /login lúc này nó sẽ chạy đến url trong controller của dự án khi đăng nhập sai nó redirect tới urll /login?error

Cuối cùng là hiển thị thông báo lỗi khi đăng nhập sai thêm vào dưới form của trang login
	<c:if test="${param.error != null}">
	<div class="my-2" style="color: red;">Invalid email or password.                                                	</div>                                                   
	</c:if>
	

	

	








	
			



		
			
	

	
	